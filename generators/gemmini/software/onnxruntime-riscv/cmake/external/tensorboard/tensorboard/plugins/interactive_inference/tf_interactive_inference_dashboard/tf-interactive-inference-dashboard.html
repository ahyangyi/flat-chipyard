<!--
@license
Copyright 2018 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<link rel="import" href="../iron-icons/av-icons.html">
<link rel="import" href="../iron-icons/communication-icons.html">
<link rel="import" href="../iron-collapse/iron-collapse.html">
<link rel="import" href="../iron-icons/editor-icons.html">
<link rel="import" href="../iron-icons/hardware-icons.html">
<link rel="import" href="../iron-icons/iron-icons.html">
<link rel="import" href="../iron-pages/iron-pages.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../paper-dialog/paper-dialog.html">
<link rel="import" href="../paper-toggle-button/paper-toggle-button.html">
<link rel="import" href="../paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../paper-listbox/paper-listbox.html">
<link rel="import" href="../paper-radio-button/paper-radio-button.html">
<link rel="import" href="../paper-radio-group/paper-radio-group.html">
<link rel="import" href="../paper-slider/paper-slider.html">
<link rel="import" href="../paper-spinner/paper-spinner-lite.html">
<link rel="import" href="../paper-tabs/paper-tab.html">
<link rel="import" href="../paper-tabs/paper-tabs.html">
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../tf-backend/tf-backend.html">
<link rel="import" href="../tf-dashboard-common/dashboard-style.html">
<link rel="import" href="../tf-dashboard-common/tf-dashboard-layout.html">
<link rel="import" href="../tf-dashboard-common/tf-option-selector.html">
<link rel="import" href="../tf-storage/tf-storage.html">
<link rel="import" href="./tf-inference-panel.html">
<link rel="import" href="../tf-tensorboard/plugin-dialog.html">
<link rel="import" href="../tf-tensorboard/registry.html">
<link rel="import" href="../vz-bar-chart/vz-bar-chart.html">
<link rel="import" href="../vz-line-chart/vz-line-chart.html">
<link rel="import" href="./tf-confusion-matrix.html">
<link rel="import" href="./tf-inference-viewer.html">
<link rel="import" href="../facets-dive/components/facets-dive/facets-dive.html">
<link rel="import" href="../facets-overview/components/facets-overview/facets-overview.html">
<link rel="import" href="../vz-example-viewer/vz-example-viewer.html">
<!--
  A frontend that displays a set of editable examples and enables inference of those examples,
  visualizing the results.
-->
<dom-module id="tf-interactive-inference-dashboard">
  <template>
    <style id="linter-paper-button-style">
      /**
       * This style preserves the styling previous to
       * https://github.com/PolymerElements/paper-button/pull/115
       * This change can break the layout of paper-button content.
       * Remove this style to apply the change, more details at b/70528356.
       */
      paper-button {
        display: inline-block;
        text-align: center;
        font-family: inherit;
      }
    </style>
    <style>
      :host {
        font-family: 'Roboto', 'Noto', sans-serif;
        --paper-tab-ink: var(--tb-orange-dark);
        --wit-color-gray300: #DADCE0;
      }

      #classification {
        width: 40%;
      }

      .example-holder {
        width: 100%;
      }

      .inference-section-holder {
        display: flex;
        margin-top: 6px;
        margin-right: 6px;
      }

      .inference-section {
        width: 100%;
        border: 1px solid var(--wit-color-gray300);
      }

      .inference-viewer {
        max-height: 35%;
        flex-grow: 1;
      }

      .compare-inference-viewer {
        border-left: 1px solid var(--wit-color-gray300);
      }

      .tf-option-selector-0 .content-wrapper.tf-option-selector  > * {
        width: 40%;
      }

      #spinner {
        position: absolute;
        top: 95px;
        left: 10px;
        width: 14px;
        height: 14px;
        --paper-spinner-color: var(--tb-orange-strong);
      }

      .noexamples {
        position: absolute;
        top: 75px;
        left: 30px;
      }

      .center {
        position: relative;
      }

      .info-text {
        font-size: 14px;
        color: #3C4043;
        letter-spacing: 0.25px;
        line-height: 20px;
        margin: 12px auto;
      }

      .pd-info-text {
        font-size: 18px;
        color: #3C4043;
        line-height: 24px;
        padding-top: 12px;
        padding-right: 4px;
        padding-left: 12px;
      }

      .pd-no-features-text {
        font-size: 18px;
        color: #3C4043;
        padding: 12px 48px;
      }

      .accept-button-holder {
        display: flex;
        flex-direction: row-reverse;
      }

      .settings-button {
        margin-top: 4px;
      }

      .button {
        font-size: 13px;
        margin: 10px 0 0 0;
        background-color: var(--tb-orange-strong);
        color: white;
      }

      .button[disabled] {
        background-color: #ccc;
      }

      .input-and-tooltip {
        display: flex;
      }

      .label-vocab-path-input {
        flex-grow: 1;
      }

      .threshold-dropdown {
        display: block;
        width: 150px;
        min-width: 150px;
        padding-right: 16px;
        --paper-input-container-input: {
          font-size: 14px;
          color: #3C4043;
        }
      }

      .counterfactual-dropdown {
        display: inline-block;
        width: 100px;
        min-width: 50px;
        padding-right: 5px;
        --paper-input-container-input: {
          font-size: 14px;
          color: #3C4043;
        }
      }

      .slider-label {
        margin-top: 8px;
      }

      .facet-label {
        --paper-input-container-underline: {
          display: none;
        };
        --paper-input-container-input: {
          font-weight: 500;
        };
      }

      .slider {
        width: 280px;
        --paper-slider-input: {
          width: 80px;
        }
      }

      .slider-model-one {
        --paper-slider-knob-color: #12B5CE;
        --paper-slider-active-color: #12B5CE;
      }

      .slider-model-two {
        --paper-slider-knob-color: #fa7817;
        --paper-slider-active-color: #fa7817;
      }

      .pr-line-chart {
        margin: 0;
        height: 200px;
        width: 280px;
        display: inline-block;
      }

      paper-dialog.inference-settings {
        padding: 20px;
        width: 40%;
        max-width: 40%;
        overflow-y: auto;
        border-radius: 10px;
      }

      .dashboard-layout {
        display: flex;
        height: 100%;
        background-color: white;
      }

      .center {
        width: 60%;
      }

      .side-holder {
        position: relative;
        width: 40%;
        display: flex;
      }

      .side-content {
        padding-left: 5px;
        width: calc(100% - 10px);
        display: flex;
        flex-direction: column;
      }

      .side-tabs {
        display: flex;
        height: calc(100% - 50px);
      }

      .datapoint-tab {
        display: flex;
        width: 100%;
        overflow: auto;
      }

      .config-tab {
        width: 100%;
        display: flex;
      }

      .config-side-content {
        padding-left: 5px;
        width: 30%;
        overflow-y: auto;
        border-right: 1px solid var(--wit-color-gray300);
      }

      .config-main-content {
        width: 70%;
        display: flex;
        flex-direction: column;
        background: #F8F9FA;
      }

      .stats-tab {
        width: 100%;
        display: flex;
        overflow: auto;
      }

      .pd-tab {
        width: 100%;
        padding: 5px 10px;
      }

      .pd-plots-header {
        height: 52px;
        min-height: 52px;
        max-height: 52px;
        border-bottom: solid 2px var(--wit-color-gray300);
        display: flex;
        justify-content: space-between;
      }

      .pdplots-holder {
        flex-grow: 1;
        overflow-y: overlay;
        background: #F8F9FA;
      }

      .pd-range-hyphen {
        padding-right: 6px;
        padding-top: 8px;
      }

      .pd-range-control {
        border-bottom: solid 1px #FCC934;
        border-top: none;
        border-left: none;
        border-right: none;
        height: 36px;
        width: 104px;
        margin-right: 6px;
      }

      #overview {
        max-height: 100%;
        height: 100%;
      }

      .inference-header.heading {
        background: #E4F7FB;
      }

      .right-side {
        position: absolute;
        right: 0;
        top: 0;
      }

      .right-side-performance-tab {
        margin: 4px;
      }

      tf-confusion-matrix {
        display: block;
      }

      .conf-matrix-holder {
        margin-top: 20px;
        margin-bottom: 18px;
        margin-right: 24px;
      }

      .conf-matrix {
        margin-bottom: 18px;
      }

      .datapoint-controls-holder.datapoint-control-buttons-holder {
        padding-left: 2px;
      }


      .datapoint-controls-holder.datapoint-control-search-holder {
        padding-left: 10px;
      }

      .datapoint-controls-holder {
        border-bottom: 1px solid var(--wit-color-gray300);
        display: flex;
        flex-grow: 0;
        flex-shrink: 0;
        justify-content: space-between;
        margin-left: 1px;
      }

      .datapoint-left-controls-holder {
        display: flex;
        flex-wrap: wrap;
      }

      .datapoint-right-controls-holder {
        display: flex;
        flex-direction: row-reverse;
      }

      .tf-category-pane {
        flex-grow: 1;
      }

      .tf-category-pane-content {
        flex-wrap: wrap;
        flex-grow: 1;
        padding: 12px;
        border: 1px solid var(--wit-color-gray300);
        border-top: none;
        border-bottom-left-radius: 2px;
        border-bottom-right-radius: 2px;
        background: white;
      }

      :host vz-line-chart {
        margin: 12px 12px 12px 24px;
        height: 180px;
        width: 300px;
        display: inline-block;
      }

      :host vz-bar-chart {
        margin: 12px 12px 12px 24px;
        height: 240px;
        width: 450px;
        display: inline-block;
      }

      .pd-input-container {
        display: block;
        flex-grow: 0;
        padding: 12px 48px 24px 24px;
        background: #FeF7E0;
        border: solid 1px #FDE293;
      }

      .style-input {
        width: 50px;
        text-align: right;
        background: white;
      }

      .feature-container-holder {
        position:absolute;
        top: 0;
        bottom: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background: white;
        display: none;
        flex-direction: column;
      }

      .datapoint-control-filter-input {
        border-radius: 2px;
        max-width: 60%;
        --paper-input-container: { padding: 4px 6px 2px 4px; };
        --paper-input-container-input: {
          font-size: 14px;
          color: #3C4043;
        }
        --paper-input-container-label: {
          font-size: 14px;
          color: #80868B;
        }
      }

      .datapoint-control-filter-input iron-icon {
        color: #9ba0a6;
      }

      .feature-search-input {
        padding-top: 3px;
        flex-grow: 1;
        max-width: 150px;
      }

      .control-button {
        background-color: white;
        border: 1px solid var(--wit-color-gray300);
        color: var(--tb-orange-dark);
        font-size: 14px;
        font-weight: 400;
        padding: 8px 12px;
        text-transform: none;
        margin: 5px;
      }

      .control-button[disabled] {
        color: #5F6368;
        background-color: #f4f4f4;
      }

      .main-button {
        background-color: var(--tb-orange-dark);
        border: 1px solid var(--tb-orange-dark);
        color: white;
        font-size: 14px;
        font-weight: 400;
        padding: 8px 12px;
        text-transform: none;
        margin: 5px;
      }

      .main-button[disabled] {
        background-color: lightgray;
        border: 1px solid lightgray;
        color: gray;
      }

      .optimize-threshold-button {
        margin: 5px 0;
        width: 150px;
        min-width: 150px;
        margin-right: 16px;
      }

      .close-partial-deps-button {
        margin: 10px;
      }

      paper-tabs {
        flex-grow: 1;
        width: 100%;
        height: 100%;
        --paper-tabs-selection-bar-color: var(--tb-orange-dark);
      }

      paper-tab {
        font-size: 14px;
        font-weight: 400;
        padding: 0 24px;
        letter-spacing: 0.1px;
      }

      paper-tab:not(.iron-selected) {
        color: #3C4043;
      }

      paper-tab.iron-selected {
        color: #202124;
        font-weight: 500;
      }

      .curves-holder {
        display: flex;
        flex-wrap: wrap;
        margin-top: 20px;
        position: relative;
      }

      .curve-holder {
        width: 300px;
        height: 235px;
        margin-bottom: 20px;
        margin-right: 20px;
        position: relative;
      }

      .roc-x-label {
        position: absolute;
        bottom: 0;
        left: 120px;
        font-size: 12px;
        color: #5f6368;
        padding: 0px;
      }

      .roc-y-label {
        position: absolute;
        left: -36px;
        bottom: 110px;
        transform: rotate(270deg);
        font-size: 12px;
        color: #5f6368;
        padding: 0px;
      }

      .pr-x-label {
        position: absolute;
        bottom: 0;
        left: 140px;
        font-size: 12px;
        color: #5f6368;
        padding: 0px;
      }

      .pr-y-label {
        position: absolute;
        left: -14px;
        bottom: 110px;
        transform: rotate(270deg);
        font-size: 12px;
        color: #5f6368;
        padding: 0px;
      }

      .flex {
        display: flex;
      }

      .space-between {
        justify-content: space-between;
      }

       .flex-wrap {
        display: flex;
        flex-wrap: wrap;
      }

      .optimize-text {
        margin: 5px 0;
        color: grey;
        font-size: 14px;
      }

      .threshold-cost-input {
        width: 150px;
        min-width: 150px;
        margin-right: 16px;
        --paper-input-container-input: {
          font-size: 14px;
          color: #3C4043;
        }
        --paper-input-container-label: {
          font-size: 14px;
          color: #80868B;
        }
      }

      .bold {
        font-weight: 500;
      }

      .indent {
        margin-left: 10px;
      }

      .feature-breakdown {
        margin-left: 12px;
      }

      .optimize-selection-button {
        margin-left: 0;
        margin-bottom: 5px;
      }

      .reg-table-category {
        text-align: left;
      }

      .reg-table-value {
        text-align: right;
      }

      .subfeature-table {
        margin-left: 10px;
      }

      .counterfactual-button-intro {
        padding: 7px 0 0 10px;
      }

      .main-vertical {
        width: 100%;
      }

      .main-bottom-bar {
        height: 52px;
        min-height: 52px;
        flex-grow: 0;
        display: flex;
        /* box-shadow: 0 2px 5px grey;
        margin-bottom: 3px; */
        border-bottom: solid 1px #DADCE0;
        justify-content: space-between;
      }

      .main-content {
        height: 100%;
      }

      .dist-switch {
        display: flex;
        margin-top: 0;
      }

      .distance-vis-dropdown {
        margin-top: 0;
      }

      #distancedialog {
        width: 30%;
      }

      #distancedialog .buttons {
        color: #f57c00;
      }

      paper-radio-button {
        --paper-radio-button-label: {
          font-size: 14px;
          color: #3C4043;
        }
        --paper-radio-button-unchecked-color: #3C4043;
        --paper-radio-button-unchecked-ink-color: #3C4043;
        --paper-radio-button-checked-color: #3C4043;
        --paper-radio-button-checked-ink-color: #3C4043;
      }

      paper-icon-button {
        color: #5F6368;
      }

      paper-icon-button[disabled] {
        color: #9AA0A6;
      }

      .resizer {
        display: table;
        height: 100%;
        width: 8px;
        border-left: 1px solid var(--wit-color-gray300);
        border-right: 1px solid var(--wit-color-gray300);
        cursor: pointer;
      }

      .example-status {
        font-size: 12px;
        color: #5F6368;
        white-space: nowrap;
        overflow: hidden;
        padding-top: 16px;
      }

      .example-id-label {
        padding: 9px 5px 9px 0;
      }

      .example-id-input {
        width: 70px;
        padding-top: 3px;
      }

      .heading-and-card {
        border: 1px solid lightgray;
        margin-right: 5px;
        margin-top: 5px;
        padding-top: 1px;
      }

      .editor-heading-and-card {
        flex: 1;
        overflow-y: overlay;
      }

      .heading {
        color: #5F6368;
        position: relative;
        padding: 10px 8px;
        background-color: #FEF7E0;
        border-bottom: 1px solid var(--wit-color-gray300);
        border-top: none;
        border-left: none;
        border-right: none;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        -webkit-tap-highlight-color: rgba(0,0,0,0);
        width: 100%;
        text-align: left;
      }

      .card {
        padding: 0 10px 5px;
      }

      .no-padding-card {
        padding: 0;
      }

      .tooltip {
        --paper-tooltip: {
          font-size: 16px;
        }
        --paper-tooltip-delay-out: 2000ms;
      }

      .comment-icon {
        width: 30px;
        height: 30px;
        min-width: 30px;
        min-height: 30px;
        margin-top: 10px;
        color: var(--tb-orange-dark);
      }

      .arrow-icon {
        width: 50px;
        height: 50px;
        min-width: 50px;
        min-height: 50px;
        color: var(--tb-orange-dark);
      }

      .pd-arrow-icon {
        width: 40px;
        height: 40px;
        min-width: 40px;
        min-height: 40px;
        margin-top: 5px;
        color: grey;
      }

      .pd-toggle {
        margin: 0 8px 0 20px;
      }

      .pd-entry-container {
        display: flex;
        flex-direction: row-reverse;
        justify-content: space-between;
        flex-grow: 1;
      }

      .info-icon {
        width: 20px;
        height: 20px;
        min-width: 20px;
        min-height: 20px;
        margin-top: 10px;
        color: grey;
      }

      .info-icon.cf-info-icon {
        margin-top: 12px;
      }

      .info-icon.thresh-info-icon {
        margin-top: -3px;
        vertical-align: middle;
      }

      .info-icon.pd-info-icon {
        margin-top: 15px;
      }

      .info-icon.threshold-info-icon {
        margin-top: 0;
        margin-bottom: 10px;
        margin-left: 5px;
      }

      .info-icon.performance-info-icon {
        margin-top: 18px;
        margin-bottom: 10px;
        margin-left: 5px;
      }

      .no-padding {
        padding: 0;
      }

      .resize-icon {
        display: table-cell;
        vertical-align: middle;
        color: grey;
        width: 10px;
        height: 10px;
        min-width: 10px;
        min-height: 10px;
      }

      .help-text {
        color: #5F6368;
        font-size: 10px;
        max-width: 200px;
      }

      .help-title {
        color: #007B7C;
        font-size: 11px;
        font-weight: 500;
        text-transform: uppercase;
      }

      .help-title-margin {
        margin-top: 14px;
      }

      .help-title-margin-button {
        margin-top: 4px;
      }

      .help-title-margin-title {
        margin-top: 7px;
      }

      .dialog-link {
        color: #5F6368;
        font-size: 10px;
        font-style: italic;
        text-decoration: underline;
        cursor: pointer;
      }

      .roc-text {
        color: #3C4043;
        font-size: 16px;
        margin-left: 44px;
      }

      .conf-text {
        margin-bottom: 12px;
        color: #3C4043;
        font-size: 16px;
      }

      .dialog-text {
        font-style: normal;
        text-align: left;
      }

      .dialog-title {
        font-size: 14px;
        font-weight: 500;
      }

      .title-width {
        width: 250px;
        padding-right: 16px;
      }

      .datapoint-info-holder {
        margin: 24px auto;
        max-width: 380px;
        padding: 24px;
      }

      .onboarding-header {
        color: #202124;
        font-size: 22px;
        margin-bottom: 28px;
      }

      .onboarding-text {
        color: #3C4043;
        font-size: 14px;
        margin-bottom: 20px;
      }

      .control-info-header {
        color: #3C4043;
        font-size: 14px;
        font-weight: 500;
        margin-top: 10px;
        margin-bottom: 15px;
      }

      .control-info-text {
        color: #3C4043;
        font-size: 14px;
        margin-bottom: 15px;
        max-width: 460px;
      }

      .button-prefix-label {
        margin: 12px 0 0 12px;
        color: grey;
        font-size: 14px;
      }

      .border-right {
        border-right: 1px solid var(--wit-color-gray300);
      }

      paper-dialog {
        color: #3C4043;
        border-radius: 10px;
        max-width: 600px;
      }

      .main-button.run-button {
        padding: 5px;
        flex-grow: 1;
      }

      .doc-image {
        width: 128px;
        height: 96px;
        border: 1px solid var(--wit-color-gray300);
      }

      .control-divider {
        margin: 5px 0 5px 5px;
        width: 5px;
        border-left: 1px solid var(--wit-color-gray300);
      }

      .optimization-radio {
        display: block;
        padding: 7px;
      }

      .optimization-radio-group {
        display: flex;
        flex-grow: 1;
        flex-direction: column;
      }

      .infer-info {
        margin-left: 30px;
      }

      .scroll-x {
        overflow-x: auto;
      }

      .perf-table-clickable {
        cursor: pointer;
      }

      .perf-table-title-row {
        background: white;
        width: 100%;
        display: flex;
        border-bottom: 1px solid var(--wit-color-gray300);
        min-height: 52px;
        justify-content: space-between;
      }
      .perf-table-title {
        color: #3C4043;
        font-size: 18px;
        margin-left: 14px;
        margin-top: 16px;
      }
      .perf-table-sort-menu {
        margin-top: -10px;
      }
      .perf-table-header {
        background: white;
        width: 100%;
        font-weight: 500;
        color: #80868B;
        font-size: 14px;
        line-height:16px;
        letter-spacing: 0.25;
        display: flex;
        border-bottom: 1px solid var(--wit-color-gray300);
        min-height: min-content;
        padding-top: 12px;
        padding-bottom: 4px;
      }

      .perf-table-entries-holder {
        overflow-y: overlay;
        flex-grow: 1;
      }

      .perf-table-entry {
        background: white;
        color: #3C4043;
        font-size: 14px;
        border-bottom: solid 1px var(--wit-color-gray300);
      }

      .perf-table-entry-expanded {
        display: flex;
        flex-wrap: wrap;
        margin: 0 12px;
        border-left: 1px solid var(--wit-color-gray300);
        border-bottom: 1px solid var(--wit-color-gray300);
        border-right: 1px solid var(--wit-color-gray300);
        background: white;
      }

      .perf-table-row {
        width: 100%;
        display: flex;
        background: white;
        position:relative;
      }

      .perf-table-row-expanded {
        width: 100%;
        display: flex;
        border-bottom: 1px solid var(--wit-color-gray300);
        border-top: 1px solid var(--wit-color-gray300);
        border-radius: 2px;
        box-shadow: 0 1px 2px 0 rgba(60,64,67,0.3), 0 1px 3px 1px rgba(60,64,67,0.15);
        background: white;
        position: relative;
      }

      .perf-table-text-entry {
        height: 40px;
        padding-top: 16px;
      }
      .perf-table-num-entry {
        height: 40px;
        padding-top: 16px;
        text-align: right;
      }
      .perf-table-arrow {
        min-width: 40px;
        width: 40px;
        margin-top: 8px;
      }
      .perf-table-val {
        width: 30%;
      }
      .perf-table-count {
        width: 10%;
        margin-right: 20px;
        text-align: right;
      }
      .perf-table-model {
        min-width: 100px;
        width: 100px;
      }
      .perf-table-model-single {
        display: none;
      }
      .perf-table-threshold {
        width: 280px;
        min-width: 280px;
        text-align: center;
      }
      .perf-table-error {
        width: 15%;
        text-align: right;
      }
      .perf-table-sq-error {
        width: 15%;
        text-align: right;
        margin-right: 20px;
      }
      .perf-table-fp {
        width: 15%;
        text-align: right;
      }
      .perf-table-fn {
        width: 15%;
        text-align: right;
      }
      .perf-table-acc {
        width: 15%;
        text-align: right;
        margin-right: 20px;
      }
      .perf-table-f1 {
        width: 10%;
        text-align: right;
        margin-right: 20px;
      }
      .perf-button {
        margin-top: 10px;
      }

      .perf-sort-box {
        display: flex;
        flex-direction: row-reverse;
      }
      .counterfactual-toggle {
        margin: 4px 4px 4px 6px;
        --paper-toggle-button-checked-bar-color: #81C995;
      }
      .datapoint-button {
        color: #202124;
        background: #FDE293;
      }
      .infer-button {
        color: white;
        background: #128EAF;
      }
      .flex-grow {
        flex-grow: 1;
      }
      .flex-row-reverse {
        flex-direction: row-reverse;
      }
      .threshold-info-holder {
        margin-top: -2px;
      }
      .tabs {
        padding-left: 32px;
        text-transform: none;
      }
      .rotated-icon {
        transform: rotate(270deg);
      }
      .datapoint-control-button {
        width: 28px;
        height: 28px;
        padding: 4px;
        margin-top: 4px;
      }
      .pd-holder {
        position: relative;
        width: 300px;
      }
      .pd-y-label {
        color: #5f6368;
        font-size: 12px;
        left: -20px;
        padding: 0px;
        position: absolute;
        top: 80px;
        transform: rotate(270deg);
      }
      .pd-x-label {
        bottom: 0;
        color: #5f6368;
        font-size: 12px;
        overflow: hidden;
        padding: 0 0 0 40px;
        position: absolute;
        text-align: center;
        text-overflow: ellipsis;
        width: 100%;
        white-space: nowrap;
      }
      paper-toggle-button {
        font-size: 14px;
        --paper-toggle-button-checked-button-color: white;
        --paper-toggle-button-label-color: #3C4043;
      }
    </style>
    <tf-plugin-dialog id="initialDialog"></tf-plugin-dialog>
    <paper-dialog id="inferencesettings" class="inference-settings" opened="[[!local]]">
      <tf-inference-panel
          inference-address="{{inferenceAddress}}"
          model-name="{{modelName}}"
          examples-path="{{examplesPath}}"
          model-type="{{modelType}}"
          model-version="{{modelVersion}}"
          model-signature="{{modelSignature}}"
          max-examples="{{maxExamples}}"
          label-vocab-path="{{labelVocabPath}}"
          multi-class="{{multiClass}}"
          sampling-odds="{{samplingOdds}}"
          sequence-examples="{{sequenceExamples}}"
          max-classes-to-display="{{maxInferenceEntriesPerRun}}"
          use-predict-api="{{usePredictApi}}"
          predict-output-tensor="{{predictOutputTensor}}"
          predict-input-tensor="{{predictInputTensor}}">
      </tf-inference-panel>
      <div class="accept-button-holder">
        <paper-button on-tap="getExamplesAndCloseSettings_" class="main-button"
                      disabled$="[[shouldDisableGetExamplesButton_(examplesPath, maxExamples)]]">
          Accept
        </paper-button>
        <paper-button dialog-dismiss class="control-button">Cancel</paper-button>
      </div>
    </paper-dialog>
    <paper-dialog id="deletedialog">
      <p>Are you sure you want to delete the selected datapoint?</p>
      <div class="buttons">
        <paper-button dialog-dismiss class="control-button">Cancel</paper-button>
        <paper-button dialog-confirm autofocus on-tap="deleteDatapoint_" class="main-button">Delete</paper-button>
      </div>
    </paper-dialog>
    <paper-dialog id="distancedialog">
      <h2>Show similarity to selected datapoint</h2>
      <paper-input value="{{facetDistFeatureName}}" label="Metric name" class="datapoint-control-filter-input">
      </paper-input>
      <div class="radiolabel">Distance type</div>
      <paper-radio-group class="dist-switch" selected="{{facetDistSwitch}}">
        <paper-radio-button class="dist-radio" name="L1">L1</paper-radio-button>
        <paper-radio-button class="dist-radio" name="L2">L2</paper-radio-button>
      </paper-radio-group>
      <paper-dropdown-menu label="Apply to datapoints visualization" class="threshold-dropdown distance-vis-dropdown">
        <paper-listbox class="dropdown-content" selected="{{facetDistSetting}}" attr-for-selected="name">
          <paper-item name="colorBy">Color By</paper-item>
          <paper-item name="horizontalFacet">X-Axis Binning</paper-item>
          <paper-item name="verticalFacet">Y-Axis Binning</paper-item>
          <paper-item name="horizontalPosition">X-Axis Scatter</paper-item>
          <paper-item name="verticalPosition">Y-Axis Scatter</paper-item>
        </paper-listbox>
      </paper-dropdown-menu>
      <div class="buttons">
        <paper-button dialog-dismiss class="control-button">Cancel</paper-button>
        <paper-button dialog-confirm autofocus on-tap="addDistanceMetric" class="main-button">Apply</paper-button>
      </div>
    </paper-dialog>
    <div class="dashboard-layout">
      <div class="main-vertical">
        <div class="main-content">
              <div class="main-bottom-bar">
                <div class="datapoint-left-controls-holder">
                  <paper-tabs class="tabs"
                    noink
                    selected="{{sideTabSelected}}">
                    <paper-tab>Datapoint editor</paper-tab>
                    <paper-tab>[[getPerformanceTabTitle(modelType, multiClass)]]</paper-tab>
                    <paper-tab>Features</paper-tab>
                  </paper-tabs>
                </div>
                <div class="datapoint-right-controls-holder">
                  <a target="_blank" href="https://github.com/tensorflow/tensorboard/tree/master/tensorboard/plugins/interactive_inference/README.md">
                    <paper-icon-button icon="help-outline" class="settings-button" title="What-If Tool documentation"></paper-icon-button>
                  </a>
                  <paper-icon-button icon="settings" on-tap="settingsClicked_" class="settings-button" title="What-If Tool settings" disabled$="[[local]]"></paper-icon-button>
                  <div class="example-status">[[exampleStatusStr]]</div>
                </div>
              </div>
              <iron-pages class="side-tabs" selected="{{sideTabSelected}}">
              <div class="datapoint-tab">
                <div class="side-holder" id="side">
                  <div class="side-content">
                    <div class="heading-and-card">
                      <button class="heading" on-tap="toggleContextTools">Visualize
                        <div class="right-side right-side-performance-tab">
                          <iron-icon icon="[[getExpandCollapseIcon(openedContextTools)]]" class="expand-collapse-button"></iron-icon>
                        </div>
                      </button>
                      <iron-collapse class="no-padding-card" id="collapsecontexttools" opened="{{openedContextTools}}">
                        <paper-radio-group selected="{{visMode}}">
                          <paper-radio-button name="dive">Datapoints</paper-radio-button>
                          <paper-radio-button name="pd">Partial dependence plots</paper-radio-button>
                        </paper-radio-group>
                        <template is="dom-if" if="[[!isRegression_(modelType)]]">
                          <div class="flex">
                            <div title="Select a datapoint to use this feature">
                              <paper-toggle-button class="counterfactual-toggle"
                                  checked="{{showNearestCounterfactual}}"
                                  disabled$="[[!hasSelected(selectedExampleAndInference)]]">
                                Show nearest counterfactual datapoint
                              </paper-toggle-button>
                            </div>
                            <paper-radio-group selected="{{nearestCounterfactualDist}}">
                              <paper-radio-button name="L1">L1</paper-radio-button>
                              <paper-radio-button name="L2">L2</paper-radio-button>
                            </paper-radio-group>
                            <paper-dropdown-menu label="Model:" no-label-float class="counterfactual-dropdown" hidden$="[[shouldHideCounterfactualModelSelector_(parsedModelNames)]]">
                              <paper-listbox class="dropdown-content" selected="{{nearestCounterfactualModelIndex}}">
                                <template is="dom-repeat" items="[[parsedModelNames]]">
                                  <paper-item>[[getCounterfactualModelName_(item)]]</paper-item>
                                </template>
                              </paper-listbox>
                            </paper-dropdown-menu>
                            <paper-icon-button icon="info-outline" class="info-icon cf-info-icon no-padding" on-tap="openDialog">
                            </paper-icon-button>
                            <paper-dialog class="dialog-text" horizontal-align="auto" vertical-align="auto">
                              <div class="dialog-title">Nearest counterfactual (neighbor of different classification)</div>
                              <div>Compares the selected datapoint with its nearest neighbor from a different classification using L1 or L2 distance.</div>
                            </paper-dialog>
                          </div>
                        </template>
                        <div title="Select a datapoint to use this feature">
                          <div class="flex">
                            <paper-button class="control-button datapoint-button" disabled$="[[!hasSelected(selectedExampleAndInference)]]"
                                on-tap="showDistanceClicked_" alt="Show similarity to selected datapoint"
                                title="Show similarity to selected datapoint">
                                Show similarity to selected datapoint
                            </paper-button>
                            <paper-icon-button icon="info-outline" class="info-icon cf-info-icon no-padding" on-tap="openDialog">
                            </paper-icon-button>
                            <paper-dialog class="dialog-text" horizontal-align="auto" vertical-align="auto">
                              <div class="dialog-title">Show similarity to selected datapoint</div>
                              <div>
                                Calculates the distance between the selected datapoint and all other datapoints and shows this
                                in the datapoints visualization.
                              </div>
                            </paper-dialog>
                          </div>
                        </div>
                      </iron-collapse>
                    </div>
                    <div class="heading-and-card editor-heading-and-card">
                      <button class="heading">[[getDatapointEditorTitle(selectedExampleNum, comparedIndices)]]
                      </button>
                      <div class="no-padding-card">
                        <div class="datapoint-controls-holder datapoint-control-buttons-holder">
                          <div class="datapoint-left-controls-holder">
                            <paper-icon-button class="datapoint-control-button" icon="chevron-left"
                              disabled$="[[!hasSelected(selectedExampleAndInference)]]"
                              on-tap="selectPrevDatapoint_" alt="select previous datapoint" title="Select previous datapoint">
                            </paper-icon-button>
                            <paper-icon-button class="datapoint-control-button" icon="chevron-right"
                              disabled$="[[!hasSelected(selectedExampleAndInference)]]"
                              on-tap="selectNextDatapoint_" alt="select next datapoint" title="Select next datapoint">
                            </paper-icon-button>
                            <div title="Edit a datapoint to use this feature">
                              <paper-icon-button class="datapoint-control-button" icon="history"
                                  on-tap="resetDatapoint_" alt="undo changes" title="Undo changes"
                                  disabled$="[[shouldDisableReset_(selectedExampleAndInference.changed)]]">
                              </paper-icon-button>
                            </div>
                            <div title="Select a datapoint to use this feature">
                              <paper-icon-button class="datapoint-control-button" icon="content-copy"
                                  disabled$="[[!hasSelected(selectedExampleAndInference)]]"
                                  on-tap="copyDatapoint_" alt="duplicate datapoint" title="Duplicate datapoint">
                              </paper-icon-button>
                            </div>
                            <div title="Select a datapoint to use this feature">
                              <paper-icon-button class="datapoint-control-button" icon="delete"
                                  disabled$="[[!hasSelected(selectedExampleAndInference)]]"
                                  on-tap="deleteDatapointDialog_" alt="delete datapoint" title="Delete datapoint">
                              </paper-icon-button>
                            </div>
                            <div class="control-divider"></div>
                            <paper-input value="{{featureSearchValue}}" label="Search features"
                                class="datapoint-control-filter-input feature-search-input"
                                disabled$="[[!hasSelected(selectedExampleAndInference)]]" no-label-float>
                              <iron-icon icon="icons:search" prefix></iron-icon>
                            </paper-input>
                          </div>
                          <div class="datapoint-right-controls-holder">
                          </div>
                        </div>
                        <template is="dom-if" if="[[hasSelected(selectedExampleAndInference)]]">
                          <div class="example-and-inference-holder">
                            <vz-example-viewer class="example-holder"
                                              json="{{selectedExampleAndInference.example}}"
                                              compare-json="{{counterfactualExampleAndInference.example}}"
                                              on-example-change="exampleChange_" id="viewer"
                                              display-mode="[[exampleDisplayMode]]"
                                              feature-search-value="{{featureSearchValue}}"
                                              compare-title="[[compareTitle]]"
                                              saliency="[[attribution]]"
                                              show-saliency
                                              readonly="[[!areExamplesEditable_(modelName, inferenceAddress)]]">
                            </vz-example-viewer>
                          </div>
                        </template>
                        <template is="dom-if" if="[[!hasSelected(selectedExampleAndInference)]]">
                          <div class="datapoint-info-holder">
                            <div class="datapoint-info-content">
                              <div class="flex space-between">
                                <div class="onboarding-header">Select a datapoint to begin exploring model behavior for your selection.</div>
                              </div>
                              <div class="onboarding-text">
                                <span class="bold">Edit and Infer:</span>
                                Edit your datapoint here and run inference in the Infer table to see differences in model behavior.
                              </div>
                              <div class="onboarding-text">
                                <span class="bold">Visualize:</span>
                                Switch between visualizing datapoints and exploring partial dependence plots to gain insights into your
                                model's behavior. Explore counterfactuals or see how similar (or different) the rest of your dataset is from
                                your selection.
                              </div>
                            </div>
                          </div>
                        </template>
                      </div>
                    </div>
                    <div class="inference-section-holder">
                      <div class="inference-section">
                        <button class="inference-header heading" on-tap="toggleInferenceResults">
                          <div class="flex">
                            <div>[[getInferTitle(selectedExampleNum, comparedIndices)]]</div>
                            <div class="right-side right-side-performance-tab">
                              <iron-icon icon="[[getExpandCollapseIcon(openedInferenceResults)]]" class="expand-collapse-button"></iron-icon>
                            </div>
                          </div>
                        </button>
                        <iron-collapse class="no-padding-card" id="collapseinference" opened="{{openedInferenceResults}}">
                          <div title="Edit a datapoint to use this feature">
                            <paper-button on-tap="inferClicked_" class="control-button infer-button flex-grow"
                              disabled$="[[shouldDisableInferButton_(examplesAndInferences, modelName, inferenceAddress, updatedExample)]]">
                              Run inference
                            </paper-button>
                          </div>
                          <div class="flex">
                            <template is="dom-if" if="[[hasSelected(selectedExampleAndInference)]]">
                              <tf-inference-viewer class="inference-viewer" inferences="[[selectedExampleAndInference.inferences]]"
                                id$="[[getInferenceHolderId_()]]" model-type="[[modelType]]" model-names="[[parsedModelNames]]" max-entries-per-run="[[maxInferenceEntriesPerRun]]">
                              </tf-inference-viewer>
                            </template>
                            <template is="dom-if" if="[[counterfactualExampleAndInference]]">
                              <tf-inference-viewer class="inference-viewer compare-inference-viewer" inferences="[[counterfactualExampleAndInference.inferences]]"
                                model-type="[[modelType]]" model-names="[[parsedModelNames]]" max-entries-per-run="[[maxInferenceEntriesPerRun]]">
                              </tf-inference-viewer>
                            </template>
                          </div>
                        </iron-collapse>
                      </div>
                    </div>
                    </div>
                    <div class="resizer" id="resizer">
                      <iron-icon icon="av:pause" class="resize-icon"></iron-icon>
                    </div>
                  </div>
                  <div class="center" id="center">
                    <facets-dive id="dive" data="[[visdata]]"
                                selected-indices="[[selected]]"
                                compared-indices="[[comparedIndices]]"
                                on-selected-indices-changed="selectedIndicesChanged_"
                                on-stats-changed="statsChanged_"
                                hide-info-card="true"
                                sprite-image-width="32" sprite-image-height="32"
                                fit-grid-aspect-ratio-to-viewport="true"
                                stable-colors="true">
                    </facets-dive>
                    <div id="noexamples" class="noexamples info-text">
                      Datapoints and their inference results will be displayed here.
                    </div>
                    <paper-spinner-lite id="spinner" hidden active></paper-spinner-lite>
                    <div class="feature-container-holder" id="partialplotholder">
                      <div class="pd-plots-header">
                        <div class="flex">
                          <div class="pd-info-text">Partial Dependence Plots</div>
                          <paper-icon-button icon="info-outline" class="info-icon pd-info-icon no-padding" on-tap="openDialog">
                          </paper-icon-button>
                          <paper-dialog class="dialog-text" horizontal-align="auto" vertical-align="auto">
                            <div class="dialog-title">Partial Dependence Plots</div>
                            <div>Partial dependence plots visualize the change in inference results for every feature,
                              as the value for that feature is changed to different valid values.
                            </div>
                            <div>For numeric features, you can set the minimum and maximum values to plot.</div>
                            <div>For string features, the most popular feature values are shown as alternatives to
                              the feature value for the selected datapoint.
                            </div>
                            <div>For features with multiple feature values per datapoint, a single plot is shown for for
                              each feature value in the selected datapoint. You can override which feature values have
                              plots created for them by specifying the indices to shown partial dependence plots for,
                              if the datapoint contains multiple feature values for a feature.
                            </div>
                            <div>When the global toggle is turned on, the plots show the average effect of repeatedly
                              changing a single feature across all datapoints. When it is turned off, the plots show the
                              effect of a repeatedly changing a single feature on the selected datapoint.
                            </div>
                          </paper-dialog>
                        </div>
                        <paper-toggle-button class="pd-toggle" checked="{{globalPdPlots}}"
                            on-change="hideAllPdElements_" disabled$="[[!hasSelected(selectedExampleAndInference)]]">
                          Global partial dependence plots
                        </paper-toggle-button>
                      </div>
                      <template is="dom-if" if="[[!areTherePdPlotFeatures_(partialDepPlotEligibleFeatures)]]">
                        <div class="pd-no-features-text">The loaded dataset has no features to show partial dependence plots for.</div>
                      </template>
                      <div class="pdplots-holder">
                        <template is="dom-repeat" items="[[partialDepPlotEligibleFeatures]]">
                          <div class="feature-container" data-feature-name$="[[item.name]]">
                            <div class="perf-table-entry perf-table-row">
                              <div class="perf-table-arrow">
                                <paper-icon-button class="pd-row-arrow rotated-icon" icon="arrow-drop-down" on-tap="categoryPaneClicked"></paper-icon-button>
                              </div>
                              <div class="perf-table-val perf-table-clickable tf-category-pane perf-table-text-entry" on-tap="categoryPaneClicked">[[item.name]]
                              </div>
                            </div>
                            <div class="pd-entry-container perf-table-entry-expanded" hidden>
                              <div class="pd-input-container" hidden$="[[shouldHidePdInputContainer(item.samples, item.name, selected)]]">
                                  <div class="range-input-container" hidden$="[[item.samples]]">
                                    <div class="info-text"
                                      title="The range of values to test (default values are automatically inferred).">
                                      Set range of values to test
                                    </div>
                                    <div class="flex">
                                      <input type="number"
                                              class="style-input x-min pd-range-control"
                                              value="[[item.observedMin]]"
                                              title="The minimum value to test (default value is automatically inferred)."
                                              on-input="pdInputChanged"/>
                                      <div class="pd-range-hyphen">-</div>
                                      <input type="number"
                                              class="style-input x-max pd-range-control"
                                              value="[[item.observedMax]]"
                                              title="The maximum value to test (default value is automatically inferred)."
                                              on-input="pdInputChanged"/>
                                    </div>
                                  </div>
                                  <div class="feature-index-container" hidden$="[[shouldHideFeatureIndicesSelector(item.name, selected)]]"
                                       title="An optional printer-page-style pattern like '0,2,4-6' to select the indices of the feature values to generate plots for. Useful for features with many repeated fields.">
                                    <div class="info-text">
                                      Set feature indices <i>(optional)</i>
                                    </div>
                                    <input type="text"
                                            class="style-input feature-index-pattern pd-range-control"
                                            on-input="pdInputChanged"/>
                                  </div>
                              </div>
                              <div class="tf-category-pane-content"></div>
                            </div>
                          </div>
                        </template>
                      </div>
                      </div>
                    </div>
              </div>
                <div class="config-tab">
                  <div class="config-side-content">
                    <div class="heading-and-card">
                      <button class="inference-header heading" on-tap="toggleTrueLabelSetup">Configure
                        <div class="right-side right-side-performance-tab">
                          <iron-icon icon="[[getExpandCollapseIcon(openedTrueLabel)]]" class="expand-collapse-button"></iron-icon>
                        </div>
                      </button>
                      <iron-collapse class="card" id="collapsetruelabel" opened="{{openedTrueLabel}}">
                        <template is="dom-if" if="[[shouldShowLabelDropdown_(stats)]]">
                          <div class="flex">
                            <paper-dropdown-menu label="Ground Truth Feature" class="threshold-dropdown">
                              <paper-listbox class="dropdown-content" selected="{{selectedLabelFeature}}" attr-for-selected="name">
                                <template is="dom-repeat" items="[[getFeatureList_(stats)]]">
                                  <paper-item name="[[item]]">[[getFeatureName_(item)]]</paper-item>
                                </template>
                              </paper-listbox>
                            </paper-dropdown-menu>
                            <div>
                              <div class="help-title help-title-margin">What is ground truth?</div>
                              <div class="help-text">
                                <div>The feature that your model is trying to predict.
                                  <span class="dialog-link" on-tap="openDialog">More.
                                    <paper-dialog class="dialog-text" horizontal-align="auto" vertical-align="auto">
                                      <div class="dialog-title">Ground Truth Feature</div>
                                      <div>If the datapoints contain a feature that represents the ground truth for what the model is attempting
                                        to predict, then selecting that feature here allows the tool to investigate the performance of
                                        the model by comparing the model's results to the ground truth feature.
                                      </div>
                                    </paper-dialog>
                                  </span>
                                </div>
                              </div>
                            </div>
                          </div>
                          <template is="dom-if" if="[[shouldShowCostRatio_(selectedLabelFeature, modelType, multiClass)]]">
                            <div class="flex">
                              <paper-input value="{{incorrectPredCostRatio}}"
                                label="Cost Ratio (FP/FN)"
                                type="number" class="threshold-cost-input">
                              </paper-input>
                              <div>
                                <div class="help-title help-title-margin">What is cost ratio?</div>
                                <div class="help-text">
                                  <div>The cost of false positives relative to false negatives. Required for optimization.
                                    <span class="dialog-link" on-tap="openDialog">More.
                                      <paper-dialog class="dialog-text" horizontal-align="auto" vertical-align="auto">
                                        <div class="dialog-title">What is cost ratio?</div>
                                        <div>This tells the tool how to optimize the classification thresholds when you use the optimization strategy controls.</div>
                                        <div>1.00 = false positives are equally as costly as false negatives.</div>
                                        <div>4.00 = false positives are 4 times more costly than false negatives</div>
                                        <div>0.25 = false negatives are 4 times more costly than false positives.</div>
                                      </paper-dialog>
                                    </span>
                                  </div>
                                </div>
                              </div>
                            </div>
                          </template>
                          <template is="dom-if" if="[[shouldShowFeatureDropdown_(stats)]]">
                            <div class="flex">
                              <paper-dropdown-menu label="Slice by" class="threshold-dropdown">
                                <paper-listbox class="dropdown-content" selected="{{selectedBreakdownFeature}}" attr-for-selected="name">
                                  <template is="dom-repeat" items="[[getFeatureList_(stats)]]">
                                    <paper-item name="[[item]]">[[getFeatureName_(item)]]</paper-item>
                                  </template>
                                </paper-listbox>
                              </paper-dropdown-menu>
                              <div>
                                <div class="help-title help-title-margin">What does slicing do?</div>
                                <div class="help-text">
                                  <div>Shows performance for each value of the selected feature.</div>
                                </div>
                              </div>
                            </div>
                            <div class="flex">
                              <template is="dom-if" if="[[shouldShowSecondFeatureDropdown_(selectedBreakdownFeature)]]">
                                <paper-dropdown-menu label="Slice by (secondary)" class="threshold-dropdown">
                                  <paper-listbox class="dropdown-content" selected="{{selectedSecondBreakdownFeature}}" attr-for-selected="name">
                                    <template is="dom-repeat" items="[[getFeatureList_(stats)]]">
                                      <paper-item name="[[item]]">[[getFeatureName_(item)]]</paper-item>
                                    </template>
                                  </paper-listbox>
                                </paper-dropdown-menu>
                              </template>
                            </div>
                          </template>
                        </template>
                      </iron-collapse>
                    </div>
                    <template is="dom-if" if="[[isBinaryClassification_(modelType, multiClass)]]">
                      <div class="heading-and-card">
                        <button class="inference-header heading" on-tap="toggleExplorerSetup">Fairness
                          <div class="right-side right-side-performance-tab">
                            <iron-icon icon="[[getExpandCollapseIcon(openedExplorer)]]" class="expand-collapse-button"></iron-icon>
                          </div>
                        </button>
                        <iron-collapse class="card" id="collapseexplorer" opened="{{openedExplorer}}">
                          <template is="dom-if" if="[[shouldShowFeatureDropdown_(stats)]]">
                            <div class="control-info-header help-title-margin-button">Apply an optimization strategy</div>
                            <div class="control-info-text">Select a strategy to set classification thresholds based on the set cost ratio and data slices.
                              Manually altering thresholds or changing cost ratio will default back to custom thresholds.
                            </div>
                            <paper-radio-group class="optimization-radio-group" selected="{{optimizationSelected}}">
                              <paper-radio-button name="custom" class="optimization-radio" id="customthresh">Custom thresholds
                                <paper-icon-button icon="info-outline" class="info-icon thresh-info-icon no-padding" on-tap="openDialog">
                                </paper-icon-button>
                                <paper-dialog class="dialog-text" horizontal-align="auto" vertical-align="bottom">
                                  <div class="dialog-title">Custom thresholds</div>
                                  <div>
                                    Set your own thresholds using the threshold sliders.
                                  </div>
                                </paper-dialog>
                              </paper-radio-button>
                              <paper-radio-button name="unaware" class="optimization-radio">Single threshold
                                <paper-icon-button icon="info-outline" class="info-icon thresh-info-icon no-padding" on-tap="openDialog">
                                </paper-icon-button>
                                <paper-dialog class="dialog-text" horizontal-align="auto" vertical-align="bottom">
                                  <div class="dialog-title">Single threshold</div>
                                  <div>
                                    Optimize a single threshold for all datapoints based on the specified cost ratio.
                                  </div>
                                </paper-dialog>
                              </paper-radio-button>
                              <paper-radio-button name="demoparity" class="optimization-radio" disabled$="[[!shouldShowFeaturePrCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]">Demographic parity
                                <paper-icon-button icon="info-outline" class="info-icon thresh-info-icon no-padding" on-tap="openDialog">
                                </paper-icon-button>
                                <paper-dialog class="dialog-text" horizontal-align="auto" vertical-align="bottom">
                                  <div class="dialog-title">Demographic parity</div>
                                  <div>
                                    Optimize a threshold per slice based on the specified cost ratio, ensuring the different slices achieve
                                    demographic party.
                                  </div>
                                  <div>
                                    Demographic parity means that similar percentages of datapoints from each slice are predicted as positive classifications.
                                  </div>
                                </paper-dialog>
                              </paper-radio-button>
                              <paper-radio-button name="equalopp" class="optimization-radio" disabled$="[[!shouldShowFeaturePrCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]">Equal opportunity
                                <paper-icon-button icon="info-outline" class="info-icon thresh-info-icon no-padding" on-tap="openDialog">
                                </paper-icon-button>
                                <paper-dialog class="dialog-text" horizontal-align="auto" vertical-align="bottom">
                                  <div class="dialog-title">Equal opportunity</div>
                                  <div>
                                    Optimize a threshold per slice based on the specified cost ratio, ensuring the different slices achieve
                                    equal opportunity.
                                  </div>
                                  <div>
                                    Equal opportunity means that among those predicted as positive classifications, there is a similar percentage of
                                    correct predictions in each slice.
                                  </div>
                                </paper-dialog>
                              </paper-radio-button>
                              <paper-radio-button name="equalacc" class="optimization-radio" disabled$="[[!shouldShowFeaturePrCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]">Equal accuracy
                                <paper-icon-button icon="info-outline" class="info-icon thresh-info-icon no-padding" on-tap="openDialog">
                                </paper-icon-button>
                                <paper-dialog class="dialog-text" horizontal-align="auto" vertical-align="bottom">
                                  <div class="dialog-title">Equal accuracy</div>
                                  <div>
                                    Optimize a threshold per slice based on the specified cost ratio, ensuring the different slices achieve
                                    equal accuracy.
                                  </div>
                                  <div>
                                    Equal accuracy means that there is a similar percentage of correct predictions in each slice.
                                  </div>
                                </paper-dialog>
                              </paper-radio-button>
                              <paper-radio-button name="group" class="optimization-radio" disabled$="[[!shouldShowFeaturePrCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]">Group thresholds
                                <paper-icon-button icon="info-outline" class="info-icon thresh-info-icon no-padding" on-tap="openDialog">
                                </paper-icon-button>
                                <paper-dialog class="dialog-text" horizontal-align="auto" vertical-align="bottom">
                                  <div class="dialog-title">Group thresholds</div>
                                  <div>
                                    Optimize a separate threshold for each slice based on the specified cost ratio.
                                  </div>
                                </paper-dialog>
                              </paper-radio-button>
                            </paper-radio-group>
                          </template>
                        </iron-collapse>
                      </div>
                    </template>
                </div>
                <div class="config-main-content">
                  <template is="dom-if" if="[[isBinaryClassification_(modelType, multiClass)]]" restamp>
                    <div class="perf-table-title-row">
                      <div class="flex">
                        <div class="perf-table-title">[[getPerfTableTitle(selectedBreakdownFeature, selectedSecondBreakdownFeature, optimizationSelected, featureValueThresholds)]]</div>
                        <paper-icon-button icon="info-outline" class="info-icon performance-info-icon no-padding" on-tap="openDialog">
                        </paper-icon-button>
                        <paper-dialog class="dialog-text" horizontal-align="auto" vertical-align="auto">
                          <div class="dialog-title">Classification Performance Table</div>
                          <div>Set the ground truth feature to explore model performance including ROC curves and confusion matrices.</div>
                          <div>Slice the dataset by features and explore model performance by slice.</div>
                          <div>Use the fairness optimization strategies and see the impact on the thresholds and performance of the individual slices.</div>
                        </paper-dialog>
                      </div>
                      <div class="perf-sort-box">
                        <div>
                          <paper-icon-button icon="unfold-more" class="perf-button" on-tap="expandAllPerformance"
                            alt="expand all slices" title="Expand all slices">
                          </paper-icon-button>
                          <paper-icon-button icon="unfold-less" class="perf-button" on-tap="collapseAllPerformance"
                            alt="collapse all slices" title="Collapse all slices">
                          </paper-icon-button>
                        </div>
                        <paper-dropdown-menu label="Sort by" class="threshold-dropdown perf-table-sort-menu">
                          <paper-listbox class="dropdown-content" selected="{{selectedFeatureSort}}" attr-for-selected="name">
                            <template is="dom-repeat" items="[[getFeatureSortBy(modelType, multiClass)]]">
                              <paper-item name="[[item]]">[[item]]</paper-item>
                            </template>
                          </paper-listbox>
                        </paper-dropdown-menu>
                      </div>
                    </div>
                    <div class="perf-table-header">
                      <div class="perf-table-arrow">
                        <iron-icon class="expand-collapse-button"></iron-icon>
                      </div>
                      <div class="perf-table-val">Feature Value</div>
                      <div class="perf-table-count">Count</div>
                      <div class$="[[getPerfTableModelClass(numModels)]]">Model</div>
                      <div class="perf-table-threshold flex">
                        <div>Threshold</div>
                        <div class="threshold-info-holder">
                          <paper-icon-button icon="info-outline" class="info-icon threshold-info-icon no-padding" on-tap="openDialog">
                          </paper-icon-button>
                          <paper-dialog class="dialog-text" horizontal-align="auto" vertical-align="auto">
                            <div class="dialog-title">Exploring Classification Performance</div>
                            <div>Use this slider to adjust the classification threshold for this slice. Inference values at or
                              above this threshold are considered a positive classification, while inference values below this
                              threshold are considered a negative classification.
                            </div>
                          </paper-dialog>
                        </div>
                      </div>
                      <div class="perf-table-fp">False Positives (%)</div>
                      <div class="perf-table-fn">False Negatives (%)</div>
                      <div class="perf-table-acc">Accuracy (%)</div>
                      <div class="perf-table-f1">F1</div>
                    </div>
                    <div class="perf-table-entries-holder">
                      <template is="dom-repeat" items="[[featureValueThresholds]]" as="featureValueThreshold">
                        <div class="perf-table-entry">
                            <div class$="[[getPerfTableRowClass(featureValueThreshold.opened)]]" data-index$="[[index]]">
                              <div class="perf-table-arrow">
                                <paper-icon-button class$="[[getExpandCollapsePerfIconClass(featureValueThreshold.opened)]]" icon="arrow-drop-down" on-tap="togglePerfRow"></paper-icon-button>
                              </div>
                              <div class="perf-table-val perf-table-clickable perf-table-text-entry" on-tap="togglePerfRow">[[getPrintableValue_(featureValueThreshold)]]</div>
                              <div class="perf-table-count perf-table-clickable perf-table-num-entry" on-tap="togglePerfRow">[[getFeatureValueCount(inferenceStats_, featureValueThreshold.threshold, featureValueThreshold)]]</div>
                              <div class$="[[getPerfTableModelClass(numModels)]]" on-tap="togglePerfRow">
                                <template is="dom-repeat" items="{{featureValueThreshold.threshold}}">
                                  <div class="perf-table-text-entry perf-table-clickable">[[getModelName_(index)]]</div>
                                </template>
                              </div>
                              <div class="perf-table-threshold">
                                <template is="dom-repeat" items="{{featureValueThreshold.threshold}}">
                                    <paper-slider class$="[[getSliderClass(index)]]" editable=true min="0" max="1" step="0.01" immediate-value="{{item.threshold}}"
                                      value="[[item.threshold]]" on-value-changed="refreshInferencesNoRegen_" on-down="resetOptimizationSelected_">
                                    </paper-slider>
                                </template>
                              </div>
                              <div class="perf-table-fp perf-table-clickable" on-tap="togglePerfRow">
                                <template is="dom-repeat" items="{{featureValueThreshold.threshold}}">
                                  <div class="perf-table-num-entry">[[getFPModelIndex(inferenceStats_, featureValueThreshold.threshold, index, featureValueThreshold)]]</div>
                                </template>
                              </div>
                              <div class="perf-table-fn perf-table-clickable" on-tap="togglePerfRow">
                                <template is="dom-repeat" items="{{featureValueThreshold.threshold}}">
                                  <div class="perf-table-num-entry">[[getFNModelIndex(inferenceStats_, featureValueThreshold.threshold, index, featureValueThreshold)]]</div>
                                </template>
                              </div>
                              <div class="perf-table-acc perf-table-clickable" on-tap="togglePerfRow">
                                <template is="dom-repeat" items="{{featureValueThreshold.threshold}}">
                                  <div class="perf-table-num-entry">[[getAccuracyModelIndex(inferenceStats_, featureValueThreshold.threshold, index, featureValueThreshold)]]</div>
                                </template>
                              </div>
                              <div class="perf-table-f1 perf-table-clickable" on-tap="togglePerfRow">
                                <template is="dom-repeat" items="{{featureValueThreshold.threshold}}">
                                  <div class="perf-table-num-entry">[[getF1ModelIndex(inferenceStats_, featureValueThreshold.threshold, index, featureValueThreshold)]]</div>
                                </template>
                              </div>
                            </div>
                        </div>
                        <iron-collapse opened="{{featureValueThreshold.opened}}">
                          <div class="perf-table-entry-expanded flex-row-reverse">
                            <template is="dom-if" if="[[shouldShowFeaturePrCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]">
                              <div class="conf-matrix-holder">
                                <div class="conf-text">Confusion matrix</div>
                                <template is="dom-repeat" items="{{featureValueThreshold.threshold}}">
                                  <tf-confusion-matrix counts="[[getConfusionCountsModelIndex(inferenceStats_, featureValueThreshold.threshold, index, featureValueThreshold)]]"
                                    label="[[getConfusionMatrixLabel(index, numModels)]]"
                                    background="[[getConfusionMatrixColor(index)]]"
                                    all-items="[[allConfMatrixLabels]]"
                                    class="conf-matrix">
                                  </tf-confusion-matrix>
                                </template>
                              </div>
                              <div class="curves-holder">
                                <div class="curve-holder">
                                  <div class="roc-text">ROC curve
                                    <paper-icon-button icon="info-outline" class="info-icon threshold-info-icon no-padding" on-tap="openDialog">
                                    </paper-icon-button>
                                    <paper-dialog class="dialog-text" horizontal-align="right" vertical-align="bottom">
                                      <div class="dialog-title">ROC curve</div>
                                      <div>A receiver operating characteristic (ROC) curve plots the true positive rate (TPR) against the
                                        false positive rate (FPR) at various classification thresholds.
                                      </div>
                                    </paper-dialog>
                                  </div>
                                  <div class="roc-x-label">False positive rate</div>
                                  <div class="roc-y-label">True positive rate</div>
                                  <vz-line-chart id="[[getRocChartId(index)]]" class="pr-line-chart"
                                      x-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                      y-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]">
                                  </vz-line-chart>
                                </div>
                                <div class="curve-holder">
                                  <div class="roc-text">PR curve
                                    <paper-icon-button icon="info-outline" class="info-icon threshold-info-icon no-padding" on-tap="openDialog">
                                    </paper-icon-button>
                                    <paper-dialog class="dialog-text" horizontal-align="right" vertical-align="bottom">
                                      <div class="dialog-title">PR curve</div>
                                      <div>A precision-recall (PR) curve plots precision against
                                        recall at various classification thresholds.
                                      </div>
                                    </paper-dialog>
                                  </div>
                                  <div class="pr-x-label">Recall</div>
                                  <div class="pr-y-label">Precision</div>
                                  <vz-line-chart id="[[getPrChartId(index)]]" class="pr-line-chart"
                                      x-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                      y-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]">
                                  </vz-line-chart>
                                </div>
                              </div>
                            </template>
                          </div>
                        </iron-collapse>
                      </template>
                      <template is="dom-if" if="[[shouldShowOverallThresholder_(selectedBreakdownFeature)]]">
                        <div class="perf-table-entry">
                          <div class="perf-table-row-expanded">
                            <div class="perf-table-arrow">
                              <paper-icon-button icon="arrow-drop-down" on-tap="togglePerfRow" disabled></paper-icon-button>
                            </div>
                            <div class="perf-table-val perf-table-text-entry">All datapoints</div>
                            <div class="perf-table-count perf-table-num-entry">[[getFeatureValueCount(inferenceStats_, overallThresholds)]]</div>
                            <div class$="[[getPerfTableModelClass(numModels)]]">
                              <template is="dom-repeat" items="{{overallThresholds}}">
                                <div class="perf-table-text-entry">[[getModelName_(index)]]</div>
                              </template>
                            </div>
                            <div class="perf-table-threshold">
                              <template is="dom-repeat" items="{{overallThresholds}}">
                                  <paper-slider class$="[[getSliderClass(index)]]" editable=true min="0" max="1" step="0.01" immediate-value="{{item.threshold}}"
                                    value="[[item.threshold]]" on-value-changed="refreshInferencesNoRegen_" on-down="resetOptimizationSelected_">
                                  </paper-slider>
                              </template>
                            </div>
                            <div class="perf-table-fp">
                              <template is="dom-repeat" items="{{overallThresholds}}">
                                <div class="perf-table-num-entry">[[getFPModelIndex(inferenceStats_, overallThresholds, index)]]</div>
                              </template>
                            </div>
                            <div class="perf-table-fn">
                              <template is="dom-repeat" items="{{overallThresholds}}">
                                <div class="perf-table-num-entry">[[getFNModelIndex(inferenceStats_, overallThresholds, index)]]</div>
                              </template>
                            </div>
                            <div class="perf-table-acc">
                              <template is="dom-repeat" items="{{overallThresholds}}">
                                <div class="perf-table-num-entry">[[getAccuracyModelIndex(inferenceStats_, overallThresholds, index)]]</div>
                              </template>
                            </div>
                            <div class="perf-table-f1">
                              <template is="dom-repeat" items="{{overallThresholds}}">
                                <div class="perf-table-num-entry">[[getF1ModelIndex(inferenceStats_, overallThresholds, index)]]</div>
                              </template>
                            </div>
                          </div>
                        </div>
                        <div class="perf-table-entry-expanded flex-row-reverse">
                          <template is="dom-if" if="[[shouldShowOverallPrChart_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]">
                            <div class="conf-matrix-holder">
                              <div class="conf-text">Confusion matrix</div>
                              <template is="dom-repeat" items="{{overallThresholds}}">
                                <tf-confusion-matrix counts="[[getConfusionCountsModelIndex(inferenceStats_, overallThresholds, index)]]"
                                  label="[[getConfusionMatrixLabel(index, numModels)]]"
                                  background="[[getConfusionMatrixColor(index)]]"
                                  all-items="[[allConfMatrixLabels]]"
                                  class="conf-matrix">
                                </tf-confusion-matrix>
                              </template>
                            </div>
                            <div class="curves-holder">
                              <div class="curve-holder">
                                <div class="roc-text">ROC curve
                                  <paper-icon-button icon="info-outline" class="info-icon threshold-info-icon no-padding" on-tap="openDialog">
                                  </paper-icon-button>
                                  <paper-dialog class="dialog-text" horizontal-align="right" vertical-align="bottom">
                                    <div class="dialog-title">ROC curve</div>
                                    <div>A receiver operating characteristic (ROC) curve plots the true positive rate (TPR) against the
                                      false positive rate (FPR) at various classification thresholds.
                                    </div>
                                  </paper-dialog>
                                </div>
                                <div class="roc-x-label">False positive rate</div>
                                <div class="roc-y-label">True positive rate</div>
                                <vz-line-chart id="rocchart" class="pr-line-chart"
                                    x-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                    y-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]">
                                </vz-line-chart>
                              </div>
                              <div class="curve-holder">
                                <div class="roc-text">PR curve
                                  <paper-icon-button icon="info-outline" class="info-icon threshold-info-icon no-padding" on-tap="openDialog">
                                  </paper-icon-button>
                                  <paper-dialog class="dialog-text" horizontal-align="right" vertical-align="bottom">
                                    <div class="dialog-title">PR curve</div>
                                    <div>A precision-recall (PR) curve plots precision against
                                      recall at various classification thresholds.
                                    </div>
                                  </paper-dialog>
                                </div>
                                <div class="pr-x-label">Recall</div>
                                <div class="pr-y-label">Precision</div>
                                <vz-line-chart id="prchart" class="pr-line-chart"
                                    x-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                    y-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]">
                                </vz-line-chart>
                              </div>
                            </div>
                          </template>
                        </div>
                      </template>
                    </div>
                  </template>
                  <template is="dom-if" if="[[isMultiClass_(modelType, multiClass)]]" restamp>
                    <div class="perf-table-title-row">
                      <div class="flex">
                        <div class="perf-table-title">[[getNoThresholdPerfTableTitle(selectedBreakdownFeature, selectedSecondBreakdownFeature, featureValueThresholds)]]</div>
                        <paper-icon-button icon="info-outline" class="info-icon performance-info-icon no-padding" on-tap="openDialog">
                        </paper-icon-button>
                        <paper-dialog class="dialog-text" horizontal-align="auto" vertical-align="auto">
                          <div class="dialog-title">Classification Performance Table</div>
                          <div>Set the ground truth feature to explore model performance including confusion matrices.</div>
                          <div>Slice the dataset and explore model performance by slice.</div>
                        </paper-dialog>
                      </div>
                      <div class="perf-sort-box">
                        <div>
                          <paper-icon-button icon="unfold-more" class="perf-button" on-tap="expandAllPerformance"
                            alt="expand all slices" title="Expand all slices">
                          </paper-icon-button>
                          <paper-icon-button icon="unfold-less" class="perf-button" on-tap="collapseAllPerformance"
                            alt="collapse all slices" title="Collapse all slices">
                          </paper-icon-button>
                        </div>
                        <paper-dropdown-menu label="Sort by" class="threshold-dropdown perf-table-sort-menu">
                          <paper-listbox class="dropdown-content" selected="{{selectedFeatureSort}}" attr-for-selected="name">
                            <template is="dom-repeat" items="[[getFeatureSortBy(modelType, multiClass)]]">
                              <paper-item name="[[item]]">[[item]]</paper-item>
                            </template>
                          </paper-listbox>
                        </paper-dropdown-menu>
                      </div>
                    </div>
                    <div class="perf-table-header">
                      <div class="perf-table-arrow"></div>
                      <div class="perf-table-val">Feature Value</div>
                      <div class="perf-table-count">Count</div>
                      <div class$="[[getPerfTableModelClass(numModels)]]">Model</div>
                      <div class="perf-table-acc">Accuracy</div>
                    </div>
                    <div class="perf-table-entries-holder">
                      <template is="dom-repeat" items="[[featureValueThresholds]]" as="featureValueThreshold">
                        <div class="perf-table-entry">
                          <div class$="[[getPerfTableRowClass(featureValueThreshold.opened)]]" data-index$="[[index]]">
                            <div class="perf-table-arrow">
                              <paper-icon-button class$="[[getExpandCollapsePerfIconClass(featureValueThreshold.opened)]]" icon="arrow-drop-down" on-tap="togglePerfRow"></paper-icon-button>
                            </div>
                            <div class="perf-table-val perf-table-clickable perf-table-text-entry" on-tap="togglePerfRow">[[getPrintableValue_(featureValueThreshold)]]</div>
                            <div class="perf-table-count perf-table-num-entry perf-table-clickable perf-table-text-entry" on-tap="togglePerfRow">
                              [[getMultiClassFeatureValueCount(inferenceStats_, featureValueThreshold)]]</div>
                            <div class$="[[getPerfTableModelClass(numModels)]]" on-tap="togglePerfRow">
                              <template is="dom-repeat" items="{{featureValueThreshold.threshold}}">
                                <div class="perf-table-text-entry perf-table-clickable">[[getModelName_(index)]]</div>
                              </template>
                            </div>
                            <div class="perf-table-acc perf-table-clickable" on-tap="togglePerfRow">
                              <template is="dom-repeat" items="{{featureValueThreshold.threshold}}">
                                <div class="perf-table-text-entry perf-table-num-entry">
                                    [[getMultiClassAccuracyModelIndex(inferenceStats_, index, featureValueThreshold)]]
                                </div>
                              </template>
                            </div>
                          </div>
                        </div>
                        <iron-collapse opened="{{featureValueThreshold.opened}}">
                          <div class="perf-table-entry-expanded flex-row-reverse scroll-x">
                            <div>
                              <template is="dom-if" if="[[shouldShowFeaturePrCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]">
                                <div class="conf-matrix-holder">
                                  <div class="conf-text">Confusion matrix</div>
                                  <template is="dom-repeat" items="[[inferenceStats_]]" as="inferenceStat">
                                    <tf-confusion-matrix counts="[[getMultiClassConfMatrix(inferenceStats_, index, featureValueThreshold)]]"
                                      label="[[getConfusionMatrixLabel(index, numModels)]]"
                                      background="[[getConfusionMatrixColor(index)]]"
                                      all-items="[[allConfMatrixLabels]]"
                                      class="conf-matrix">
                                    </tf-confusion-matrix>
                                    </template>
                                </div>
                              </template>
                            </div>
                          </div>
                        </iron-collapse>
                      </template>
                      <template is="dom-if" if="[[shouldShowOverallThresholder_(selectedBreakdownFeature)]]">
                        <div class="perf-table-entry">
                          <div class="perf-table-row-expanded">
                            <div class="perf-table-arrow">
                              <paper-icon-button icon="arrow-drop-down" on-tap="togglePerfRow" disabled></paper-icon-button>
                            </div>
                            <div class="perf-table-val perf-table-text-entry">All datapoints</div>
                            <div class="perf-table-count perf-table-num-entry">
                                [[getMultiClassFeatureValueCount(inferenceStats_)]]
                            </div>
                            <div class$="[[getPerfTableModelClass(numModels)]]">
                              <template is="dom-repeat" items="{{overallThresholds}}">
                                <div class="perf-table-text-entry">[[getModelName_(index)]]</div>
                              </template>
                            </div>
                            <div class="perf-table-acc">
                              <template is="dom-repeat" items="[[inferenceStats_]]" as="inferenceStat">
                                <div class="perf-table-text-entry perf-table-num-entry">
                                    [[getMultiClassAccuracyModelIndex(inferenceStats_, index)]]
                                </div>
                              </template>
                            </div>
                          </div>
                        </div>
                        <div class="perf-table-entry-expanded flex-row-reverse scroll-x">
                          <template is="dom-if" if="[[shouldShowOverallPrChart_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]">
                            <div class="conf-matrix-holder">
                              <div class="conf-text">Confusion matrix</div>
                              <template is="dom-repeat" items="[[inferenceStats_]]" as="inferenceStat">
                                <tf-confusion-matrix counts="[[getMultiClassConfMatrix(inferenceStats_, index)]]"
                                  label="[[getConfusionMatrixLabel(index, numModels)]]"
                                  background="[[getConfusionMatrixColor(index)]]"
                                  all-items="[[allConfMatrixLabels]]"
                                  class="conf-matrix">
                                </tf-confusion-matrix>
                              </template>
                            </div>
                          </template>
                        </div>
                      </template>
                    </div>
                  </template>
                  <template is="dom-if" if="[[isRegression_(modelType)]]" restamp>
                    <div class="perf-table-title-row">
                      <div class="flex">
                        <div class="perf-table-title">[[getNoThresholdPerfTableTitle(selectedBreakdownFeature, selectedSecondBreakdownFeature, featureValueThresholds)]]</div>
                        <paper-icon-button icon="info-outline" class="info-icon performance-info-icon no-padding" on-tap="openDialog">
                        </paper-icon-button>
                        <paper-dialog class="dialog-text" horizontal-align="auto" vertical-align="auto">
                          <div class="dialog-title">Regression Performance Table</div>
                          <div>Set the ground truth feature to explore model performance.</div>
                          <div>Slice the dataset and explore model performance by slice.</div>
                        </paper-dialog>
                      </div>
                        <paper-dropdown-menu label="Sort by" class="threshold-dropdown perf-table-sort-menu">
                        <paper-listbox class="dropdown-content" selected="{{selectedFeatureSort}}" attr-for-selected="name">
                          <template is="dom-repeat" items="[[getFeatureSortBy(modelType, multiClass)]]">
                            <paper-item name="[[item]]">[[item]]</paper-item>
                          </template>
                        </paper-listbox>
                      </paper-dropdown-menu>
                    </div>
                    <div class="perf-table-header">
                      <div class="perf-table-arrow"></div>
                      <div class="perf-table-val">Feature Value</div>
                      <div class="perf-table-count">Count</div>
                      <div class="perf-table-error">Mean error</div>
                      <div class="perf-table-error">Mean absolute error</div>
                      <div class="perf-table-sq-error">Mean squared error</div>
                    </div>
                    <div class="perf-table-entries-holder">
                      <template is="dom-repeat" items="[[regressionEntries_]]">
                        <div class="perf-table-entry">
                          <div class="perf-table-row">
                            <div class="perf-table-arrow"></div>
                            <div class="perf-table-val perf-table-text-entry">[[item.name]]</div>
                            <div class="perf-table-count perf-table-num-entry perf-table-text-entry">
                              [[item.count]]
                            </div>
                            <div class="perf-table-error perf-table-num-entry perf-table-text-entry">
                              [[formatError(item.meanError)]]
                            </div>
                            <div class="perf-table-error perf-table-num-entry perf-table-text-entry">
                              [[formatError(item.meanAbsError)]]
                            </div>
                            <div class="perf-table-sq-error perf-table-num-entry perf-table-text-entry">
                              [[formatError(item.meanSquaredError)]]
                            </div>
                          </div>
                        </div>
                      </template>
                    </div>
                  </template>
                </div>
              </div>
                <div class="stats-tab">
                  <facets-overview id="overview" search-string="{{featureSearchValue}}"></facets-overview>
                </div>
              </iron-pages>
            </div>
      </div>
    </div>
    <style include="dashboard-style"></style>
  </template>

  <script>
    const maxStringLengthToDecode = 100000;
    const inferenceLabelStr = ' Inference label';
    const inferenceValueStr = ' Inference value';
    const inferenceCorrectStr = ' Inference correct';
    const inferenceErrorStr = ' Inference error';
    const inferenceAbsErrorStr = ' Inference absolute error';
    const inferenceSquaredErrorStr = ' Inference squared error';
    const inferenceScoreStr = ' Inference score';
    const exampleIdKey = ' Datapoint ID';

    // Special feature names and feature name prefixes and suffixes for parsing
    // inference and attribution information from TFMA-generated input.
    const classificationResultsKey = 'predictions__probabilities';
    const regressionResultsKey = 'predictions';
    const attributionPrefix = 'attributions__';
    const featureForAttributionPrefix = 'features__';
    const attributionSparseKeySuffix = '_keys';
    const attributionSparseValueSuffix = '_values';

    function deleteElement(elt){
      if (elt && elt.parentElement){
        elt.parentElement.removeChild(elt);
      }
    }

    (function() {

    const PLUGIN_NAME = 'whatif';

    Polymer({
      is: "tf-interactive-inference-dashboard",
      properties: {

        // TensorBoard plugin standard.
        _requestManager: {
          type: Object,
          value: () => new tf_backend.RequestManager(),
        },
        _canceller: {
          type: Object,
          value: () => new tf_backend.Canceller(),
        },

        // User-provided fields for WIT plugin from settings dialog.
        examplesPath: {
          type: String,
        },
        modelName: {
          type: String,
          observer: 'modelNameChanged_',
        },
        parsedModelNames: {
          type: String,
        },
        inferenceAddress: {
          type: String,
        },
        modelType: {
          type: String,
        },
        modelSignature: {
          type: String,
        },
        modelVersion: {
          type: String,
        },
        maxExamples: {
          type: Number,
        },
        labelVocabPath: {
          type: String,
        },
        maxInferenceEntriesPerRun: Number,

        // Inferences from servo.
        inferences: {
          type: Object,
          observer: 'newInferences_',
          value: () => ({})
        },
        // Attributions from inference. A dict with two fields: 'indices' and
        // 'attributions'. Indices contains a list of example indices that
        // these new attributions apply to. Attributions contains a list of
        // attributions for each of those examples.
        // The attribution object for each example is a dict of feature name
        // to attribution value.
        // The attribution value is one of the following:
        // - A single number representing the attribution to that entire feature
        //   value.
        // - A list of numbers representing the attributions to individual
        //   values of a multivalent feature - such as pixels in an image or
        //   numbers in a list of numbers.
        // - A 2D list for sparse attributions of a multivalent feature. The
        //   first list contains the feature values for which attributions
        //   exist. The second list contains the numeric attributions for each
        //   of those feature values.
        attributions: {
          type: Object,
          observer: 'newAttributions_',
        },
        // Examples and their inferences merged into a single list.
        // # Samples -> .inferences -> # Inferences -> # Models -> # Labels
        examplesAndInferences : {
          type: Array,
          value: () => ([]),
          observer: 'computeSelectedExampleAndInference',
        },
        // The currently selected item from the examplesAndInferences list,
        // selected through clicking in Facets Dive.
        /** @type {?Object} */
        selectedExampleAndInference : {
          type: Object,
        },
        // The closest counterfatual example to the currently selected item,
        // if one is found through the counterfactual button.
        /** @type {?Object} */
        counterfactualExampleAndInference : {
          type: Object,
        },
        // The examples list in the format to provide to Facets Dive.
        // Each element in the list represents a datapoint and is a dictionary
        // with keys being the features and values being the value of a feature,
        // or a list of values for those features that contain more than one
        // feature value.
        visdata: {
          type: Array,
          value: () => ([]),
        },
        // The selected items list provided by Facets Dive. The What-If Tool
        // only makes use of the first selected item, but Facets Dive itself
        // maintains a list of all selected items and this is bound to that
        // list provided by Facets Dive.
        selected: {
          type: Array,
          value: () => ([]),
          observer: 'computeSelectedExampleAndInference',
        },
        // The selected item to compare, provided to Facets Dive.
        comparedIndices: {
          type: Array,
          value: () => ([]),
        },
        // List of strings corresponding to inference numeric labels for
        // classification models, from file at labelVocabPath.
        labelVocab: {
          type: Array,
          value: () => ([]),
        },
        // True if an example has been updated.
        updatedExample: {
          type: Boolean,
          value: false,
        },
        imageFeatureName: {
          type: String,
          value: 'image/encoded',
          readonly: true,
        },
        // The dataset stats from Facets Dive to be used for the classification
        // threshold logic.
        stats: Object,
        // Feature to see performance breakdowns for the values of.
        selectedBreakdownFeature: {
          type: String,
          value: '',
          observer: 'breakdownFeatureSelected_',
        },
        // Second feature to see performance breakdowns for the values of,
        // crossed with the first selected feature.
        selectedSecondBreakdownFeature: {
          type: String,
          value: '',
          observer: 'breakdownFeatureSelected_',
        },
        // Feature for true label.
        selectedLabelFeature: {
          type: String,
          value: '',
          observer: 'labelFeatureSelected_',
        },
        // Choose which model is used for counterfactual computation
        nearestCounterfactualModelIndex: {
          type: Number,
          value: 0,
        },
        // Calculated statistics from the inference results.
        inferenceStats_: {
          type: Array,
          value: () => ([]),
        },
        // Array of feature values and their set classification thresholds, for
        // Polymer display purposes.
        featureValueThresholds: {
          type: Array,
          value: () => ([]),
        },
        // A map of feature name to the featureValueThresholds items, for quick
        // lookup.
        featureValueThresholdsMap: Object,
        // The default inference label when the classification threshold isn't
        // met.
        defaultInferenceLabel: {
          type: Number,
          value: 0,
          observer: 'refreshInferences_',
        },
        // The classification threshold when it isn't being set on a
        // per-feature-value basis. One per model.
        overallThresholds: {
          type: Array,
          value: () => ([]),
        },
        // Which side-tab is selected.
        sideTabSelected: {
          type: Number,
          value: 0,
          observer: 'sideTabSelectedChanged_'
        },
        // Boolean for if running in "local" demo mode, meaning this isn't
        // part of a TensorBoard build and has no backend.
        local: {
          type: Boolean,
          value: false,
          observer: 'localChanged_',
        },
        // Atlas URL for "local" demo mode.
        localAtlasUrl: String,
        // List of features for which we can make partial dep plots.
        partialDepPlotEligibleFeatures: {
          type: Array,
          value: () => ([]), // [{name: 'a_numeric_feature', observedMin: -10,
                             //   observedMax: 10},
                             // {name: 'a_categorical_feature', samples: []}]
          observer: 'partialDepPlotEligibleFeaturesSet'
        },
        // Features that we are currently creating partial dep plots for.
        partialDepPlotPendingFeatures: {
          type: Array,
          value: () => ([]),
        },
        // Mode of how individual examples are display in the side panel.
        exampleDisplayMode: {
          type: String,
          value: 'stacked'
        },
        // Search string for feature searching.
        featureSearchValue: String,
        // Ratio of false positive to false negative for grading classification
        // thresholds.
        incorrectPredCostRatio: {
          type: Number,
          value: 1,
          observer: 'costRatioChanged_',
        },
        // If the classification model is a multi-class model.
        multiClass: {
          type: Boolean,
        },
        // If the examples loaded are SequenceExamples.
        sequenceExamples: {
          type: Boolean,
        },
        // Sampling odds (1: load all examples, .2: sample 20% of examples)
        samplingOdds: {
          type: Number,
        },
        // Whether to use the TF Serving Predict API or not.
        usePredictApi: {
          type: Boolean,
        },
        // Name of the output tensor to parse when using the Predict API.
        predictOutputTensor: {
          type: String,
        },
        // Name of the intput tensor to parse when using the Predict API.
        predictInputTensor: {
          type: String,
        },
        // Precision on charts for performance measuring.
        axisPrecision: {
          type: Number,
          value: 2,
        },
        // Stats calculated from the overview stats proto used for determining
        // counterfactual example distance.
        distanceStats_: {
          type: Object
        },
        // Whether to show distance to selected example by L1 or L2 distance.
        facetDistSwitch: {
          type: String,
          value: 'L1'
        },
        // Facets Dive feature name for distance to the selected example.
        facetDistFeatureName: {
          type: String,
        },
        // All previously-created feature names for distances to selected
        // examples.
        facetDistFeatureNames: {
          type: Array,
          value: () => ([]),
        },
        // What Facets Dive setting to use to show distance to selected
        // example.
        facetDistSetting: {
          type: String,
          value: 'colorBy'
        },
        exampleStatusStr: {
          type: String,
          value: 'No datapoints loaded yet'
        },
        // The example ID number selected in the text input
        selectedExampleNum: {
          type: Number,
          value: '',
          observer: 'selectedExampleInputChanged_'
        },
        // The max ID number for a selected example.
        selectedExampleMax: Number,
        openedContextTools: {
          type: Boolean,
          value: true
        },
        openedPerformance: {
          type: Boolean,
          value: true
        },
        openedTrueLabel: {
          type: Boolean,
          value: true
        },
        openedExplorer: {
          type: Boolean,
          value: true
        },
        openedInferenceResults: {
          type: Boolean,
          value: true
        },
        regressionEntries_: {
          type: Array
        },
        nearestCounterfactualDist: {
          type: String,
          value: "L1",
        },
        visMode: {
          type: String,
          value: 'dive',
          observer: 'visModeChanged_'
        },
        // The optimization setting selected for setting classification
        // thresholds.
        optimizationSelected: {
          type: String,
          value: 'custom',
          observer: 'optimizationSelectedChanged_',
        },
        compareTitle: String,
        // Dictionary of features to feature value attributions for display
        // in the example viewer. Filled in if the selected example contains
        // attribution information.
        attribution: {
          type: Object,
          value: () => ({}),
        },
        // True if showing global PD plots. False if showing individual PD
        // plots.
        globalPdPlots: {
          type: Boolean,
          value: true,
        },
        // Number of models, only updated when user clicks "Accept" in settings
        // pane
        numModels: {
          type: Number,
          readOnly: true,
        },
        // Show nearest counterfactual toggle button setting.
        showNearestCounterfactual: {
          type: Boolean,
          value: false,
        },
        selectedFeatureSort: {
          type: String,
          value: 'Count',
          observer: 'selectedFeatureSortChanged_',
        },
        // Colors for lines and bars in partial dependence plots.
        pdPlotColors: {
          type: Array,
          value: () => ([d3.color('rgb(31, 119, 180)'),
                         d3.color('rgb(255, 127, 14)'),
                         d3.color('rgb(44, 160, 44)'),
                         d3.color('rgb(214, 39, 40)'),
                         d3.color('rgb(148, 103, 189)'),
                         d3.color('rgb(140, 86, 75)'),
                         d3.color('rgb(227, 119, 194)'),
                         d3.color('rgb(127, 127, 127)'),
                         d3.color('rgb(188, 189, 34)'),
                         d3.color('rgb(23, 190, 207)')]),
        },
        // Transparent version of colors for partial dependence plots for
        // indicating classification threshold values.
        pdPlotTransparentColors: {
          type: Array,
          value: () => ([d3.color('rgba(31, 119, 180, 0.3)'),
                         d3.color('rgba(255, 127, 14, 0.3)'),
                         d3.color('rgba(44, 160, 44, 0.3)'),
                         d3.color('rgba(214, 39, 40, 0.3)'),
                         d3.color('rgba(148, 103, 189, 0.3)'),
                         d3.color('rgba(140, 86, 75, 0.3)'),
                         d3.color('rgba(227, 119, 194, 0.3)'),
                         d3.color('rgba(127, 127, 127, 0.3)'),
                         d3.color('rgba(188, 189, 34, 0.3)'),
                         d3.color('rgba(23, 190, 207, 0.3)')]),
        },
        // Colors for lines in ROC curves
        rocCurveColors: {
          type: Array,
          value: () => ([d3.color('rgb(18, 181, 206)'),
                         d3.color('rgb(250, 120, 23)')]),
        },
        rocCurveLineColors: {
          type: Array,
          value: () => ([d3.color('rgba(18, 181, 206, 0.6)'),
                         d3.color('rgba(250, 120, 23, 0.6)')]),
        },
        // Colors for confusion matrix backgrounds.
        confMatrixColors: {
          type: Array,
          value: () => ([d3.color('rgb(18, 181, 206)'),
                         d3.color('rgb(250, 120, 23)')]),
        },
        // Dictionary where keys contain all cell labels for confusion
        // matrices.
        allConfMatrixLabels: {
          type: Array,
          value: () => ([]),
        }
      },

      observers: [
        'setFacetDistFeatureName(facetDistSwitch, selected)',
        'nearestCounterfactualStatusChanged_(showNearestCounterfactual, nearestCounterfactualModelIndex, nearestCounterfactualDist)'
      ],

      // Required function.
      reload: function(){
      },

      openDialog: function(event) {
        event.stopPropagation();
        const dialog = event.target.parentElement.parentElement
          .querySelector('paper-dialog');
        dialog.open();
      },

      ready: function() {
        const side = d3.select(this.$.side);
        const center = d3.select(this.$.center);
        const resizer = d3.select(this.$.resizer);
        const self = this;

        const dragResize = d3.drag().on('drag', () => {
          // Determine resizer position relative to width of the tool.
          const x = d3.mouse(this.parentNode.parentNode)[0];
          const width = this.parentNode.parentNode.offsetWidth;
          let perc = x / width * 100;

          // Side panel will be a minimum of 20% width.
          perc = Math.max(perc, 20);

          center.style('width', (100 - perc) + '%');
          side.style('width', perc + '%');

          // Force the Dive visualization to recompute item positions and handle
          // changed container size.
          self.$.dive.$.vis._updateGridFaceting();
          self.$.dive.$.vis._onIronResize();
        });

        resizer.call(dragResize);
      },

      attached: function() {
        // Check if the plugin was created
        this._requestManager
            .request(tf_backend.getRouter().pluginsListing())
            .then(plugins => {
              if (!(PLUGIN_NAME in plugins)) {
                // The plugin was not created
                this.$.inferencesettings.close();
                this.$.initialDialog.openNoTensorFlowDialog();
              } else {
                // The plugin was created
                this.$.initialDialog.closeDialog();
              }
            });
      },

      settingsClicked_: function() {
        this.$.inferencesettings.toggle();
      },

      localChanged_: function() {
        if (this.local) {
          this.closeSettings_();
        }
      },

      modelNameChanged_: function() {
        this.parsedModelNames = this.modelName.split(',').map(
          str => str.trim());
        // If any names are identical, then add an index-based postfix
        // to make them unique, for display purposes.
        for (let i = 0; i < this.parsedModelNames.length; i++) {
          const currentName = this.parsedModelNames[i];
          for (let j = i + 1; j < this.parsedModelNames.length; j++) {
            if (this.parsedModelNames[j] == currentName) {
              this.parsedModelNames[i] = currentName + ' ' + (i + 1)
              this.parsedModelNames[j] = currentName + ' ' + (j + 1);
            }
          }
        }
      },

      closeSettings_: function() {
        this.$.inferencesettings.close();
      },

      showDistanceClicked_: function() {
        this.$.distancedialog.toggle();
      },

      addDistanceMetric: function() {
        this.facetDistFeatureNames.push(this.facetDistFeatureName);
        const selected = this.selected[0];
        let closestDist = Number.POSITIVE_INFINITY;
        let closest = -1;
        const useL2Distance = this.facetDistSwitch == 'L2';
        for (let i = 0; i < this.visdata.length; i++) {
          let dist = this.getDist(
            this.visdata[selected], this.visdata[i], useL2Distance);
          this.visdata[i][this.facetDistFeatureName] = dist;
        }
        this.refreshDive_();
        if (this.facetDistSetting == 'colorBy') {
          this.$.dive.colorBy = this.facetDistFeatureName;
        } else if (this.facetDistSetting == 'verticalFacet') {
          this.$.dive.verticalFacet = this.facetDistFeatureName;
        } else if (this.facetDistSetting == 'horizontalFacet') {
          this.$.dive.horizontalFacet = this.facetDistFeatureName;
        } else if (this.facetDistSetting == 'verticalPosition') {
          this.$.dive.verticalPosition = this.facetDistFeatureName;
        } else if (this.facetDistSetting == 'horizontalPosition') {
          this.$.dive.horizontalPosition = this.facetDistFeatureName;
        }
      },

      setFacetDistFeatureName: function(facetDistSwitch, selected) {
        this.facetDistFeatureName = ' ' + facetDistSwitch +
            ' distance to datapoint ' + selected[0];
      },

      nearestCounterfactualStatusChanged_: function(show) {
        if (show) {
          this.findClosestCounterfactual_();
        } else {
          this.comparedIndices = [];
          this.counterfactualExampleAndInference = null;
          const temp = this.selectedExampleAndInference;
          this.selectedExampleAndInference = null;
          this.selectedExampleAndInference = temp;
        }
      },

      findClosestCounterfactual_: function() {
        const selected = this.selected[0];
        const modelInferenceValueStr =
            this.strWithModelName_(inferenceValueStr,
                                   this.nearestCounterfactualModelIndex);
        let closestDist = Number.POSITIVE_INFINITY;
        let closest = -1;
        for (let i = 0; i < this.visdata.length; i++) {
          // Skip examples with the same inference class as the selected
          // examples.
          if (this.visdata[selected][modelInferenceValueStr] ==
              this.visdata[i][modelInferenceValueStr]) {
            continue;
          }
          let dist = this.getDist(
            this.visdata[selected], this.visdata[i],
            this.nearestCounterfactualDist == 'L2');
          if (dist < closestDist) {
            closestDist = dist;
            closest = i;
          }
        }
        if (closest != -1) {
          // Display the counterfactual in dive and example viewer.
          this.comparedIndices = [closest];
          this.counterfactualExampleAndInference =
            this.examplesAndInferences[closest];
          this.compareTitle = 'Counterfactual value(s)'
        }
      },

      /**
       * Gets distance between two examples using L1 or L2 distance.
       */
      getDist: function(a, b, useL2Distance) {
        let dist = 0;
        const allKeys = [...new Set([...Object.keys(a), ...Object.keys(b)])];
        for (let featIndex = 0; featIndex < allKeys.length; featIndex++) {
          const feat = allKeys[featIndex];
          // Skip inferred keys, label feature and features with only unique
          // values.
          if (this.isComputedKeyStr_(feat) ||
              feat == this.selectedLabelFeature ||
              this.stats[feat].uniqueCount ==
              this.examplesAndInferences.length) {
            continue;
          }
          let aVals = a[feat];
          let bVals = b[feat];
          if (!Array.isArray(aVals)) {
            aVals = [aVals];
          }
          if (!Array.isArray(bVals)) {
            bVals = [bVals];
          }
          const maxLength = Math.max(aVals.length, bVals.length);
          let featureTotalDist = 0;
          for (let i = 0; i < maxLength; i++) {
            if (this.distanceStats_[feat].stdDev != null) {
              featureTotalDist +=
                this.getNumericDist(aVals[i], bVals[i],
                this.distanceStats_[feat]);
            } else {
              featureTotalDist +=
                this.getCategoricalDist(aVals[i], bVals[i],
                this.distanceStats_[feat]);
            }
          }
          let newDist = featureTotalDist / maxLength;
          if (useL2Distance) {
            newDist *= newDist;
          }
          dist += newDist;
        }
        return dist;
      },

      /** Gets distance between two numeric feature values. */
      getNumericDist: function(a, b, stats) {
        if (a == null || b == null) {
          return 1;
        }
        if (!stats.stdDev) {
          return 0;
        }
        // Return the difference divided by the standard deviation of that
        // feature across all examples.
        return Math.abs((a - b) / stats.stdDev);
      },

      /** Gets distance between two categorical feature values. */
      getCategoricalDist: function(a, b, stats) {
        if (a == null || b == null) {
          return 1;
        }
        if (a == b) {
          return 0;
        }
        // If they are different return the probability that any two examples
        // have the same feature value for this feature.
        return stats.probSameValue;
      },

      visModeChanged_: function(mode) {
        mode == 'dive' ?
            this.hidePartialDependencePlots_() :
            this.showPartialDependencePlots_();
      },

      hidePartialDependencePlots_: function() {
        this.$.partialplotholder.style.display = 'none';
      },

      showPartialDependencePlots_: function() {
        this.$.partialplotholder.style.display = 'flex';
        requestAnimationFrame(() => this.populatePdTabs());
      },

      areTherePdPlotFeatures_: function(partialDepPlotEligibleFeatures) {
        return partialDepPlotEligibleFeatures &&
          partialDepPlotEligibleFeatures.length > 0;
      },

      selectedIndicesChanged_: function(event) {
        this.selected = event.detail.value;
        this.setAttributions();
        this.selectedDataUpdated_();
        if (this.showNearestCounterfactual && this.selected.length != 0) {
          this.findClosestCounterfactual_();
        } else {
          this.comparedIndices = [];
        }
      },

      selectNextDatapoint_: function() {
        const id = (this.selected[0] + 1) % this.visdata.length;
        this.$.dive.selectedIndices = [id];
      },

      selectPrevDatapoint_: function() {
        const id = (((this.selected[0] - 1) % this.visdata.length) +
            this.visdata.length) % this.visdata.length
        this.$.dive.selectedIndices = [id];
      },

      selectedExampleInputChanged_: function(newDatapoint) {
        if (newDatapoint == null || newDatapoint == "") {
          return;
        }
        const id = +newDatapoint;
        if (isNaN(id) || id < 0 || id >= this.visdata.length) {
          return;
        }
        this.$.dive.selectedIndices = [id];
      },

      setExampleCollapsed_: function() {
        this.exampleDisplayMode = 'grid';
        this.$$('#viewer').expandedFeatures = {};
        this.$$('#viewer').expandAllFeatures = false;
        this.$$('#viewer').refreshExampleViewer();
      },

      setExampleShow_: function() {
        this.exampleDisplayMode = 'grid';
        this.$$('#viewer').expandAllFeatures = true;
      },

      setExampleExpanded_: function() {
        this.exampleDisplayMode = 'stacked';
        this.$$('#viewer').expandAllFeatures = true;
      },

      statsChanged_: function(event) {
        this.stats = event.detail.value;
      },

      isBinaryClassification_: function(modelType, multiClass) {
        return modelType == 'classification' && !multiClass;
      },

      isMultiClass_: function(modelType, multiClass) {
        return modelType == 'classification' && multiClass;
      },

      isRegression_: function(modelType) {
        return modelType == 'regression';
      },

      shouldShowFeatureDropdown_: function(stats) {
        return stats && Object.keys(stats).length > 0;
      },

      shouldShowSecondFeatureDropdown_: function(selectedBreakdownFeature) {
        return selectedBreakdownFeature != '';
      },

      shouldShowLabelDropdown_: function(stats) {
        return stats && Object.keys(stats).length > 0;
      },

      shouldHideCounterfactualModelSelector_: function(modelNames) {
        return !(modelNames && modelNames.length > 1);
      },

      shouldShowOverallPrChart_: function(selectedLabelFeature,
          selectedBreakdownFeature, inferences) {
        return selectedLabelFeature != '' && selectedBreakdownFeature == '' &&
          inferences != null;
      },

      shouldShowFeaturePrCharts_: function(selectedLabelFeature,
          selectedBreakdownFeature, inferences) {
        return selectedLabelFeature != '' && selectedBreakdownFeature != '' &&
          inferences != null;
      },

      shouldShowCostRatio_: function(selectedLabelFeature, modelType,
          multiClass) {
        return selectedLabelFeature != '' &&
          this.isBinaryClassification_(modelType, multiClass);
      },

      arePartialDependencePlotsEnabled_: function(
          selectedExampleAndInference, modelName, inferenceAddress) {
        return this.hasSelected(selectedExampleAndInference) &&
          this.areExamplesEditable_(modelName, inferenceAddress);
      },

      hasSelected: function(selectedExampleAndInference) {
        return selectedExampleAndInference != null;
      },

      getFeatureList_: function(stats) {
        // Do not also threshold settings by the results of the inference as
        // they aren't real data features.
        const features = Object.keys(stats).filter(
          feature => !this.isComputedKeyStr_(feature)).sort();
        // Add a blank feature to be used for clearing the selected feature.
        features.push('');
        return features;
      },

      strStartsWith_: function(inStr, prefixStr){
        return inStr.lastIndexOf(prefixStr, 0) == 0;
      },

      getModelName_: function(modelNumber) {
        return this.parsedModelNames[modelNumber];
      },

      strWithModelName_: function(inStr, modelNumber) {
        if (this.numModels > 1) {
          return inStr + ' ' + this.getModelName_(modelNumber);
        } else {
          return inStr
        }
      },

      updateNumberOfModels: function () {
        this._setNumModels(this.modelName.split(',').length);
        // Initialize default overall thresholds
        this.selectedLabelFeature = '';
        this.selectedBreakdownFeature = '';
        this.selectedSecondBreakdownFeature = '';
        const overallThresholds = [];
        for (let modelInd = 0; modelInd < this.numModels; modelInd++) {
          overallThresholds.push({threshold: 0.5})
        }
        this.set('overallThresholds', overallThresholds);

        // If inference can be performed automatically at this point, due to
        // examples already being set, and now the model being set, then
        // cause inference to run.
        if (!this.shouldDisableInferButton_(
            this.examplesAndInferences, this.modelName, this.inferenceAddress,
            this.updatedExample)) {
          this.inferClicked_();
        }
      },

      isComputedKeyStr_: function(feature) {
        return this.strStartsWith_(feature, inferenceValueStr)
            || this.strStartsWith_(feature, inferenceLabelStr)
            || this.strStartsWith_(feature, inferenceCorrectStr)
            || this.strStartsWith_(feature, inferenceErrorStr)
            || this.strStartsWith_(feature, inferenceScoreStr)
            || this.strStartsWith_(feature, inferenceAbsErrorStr)
            || this.strStartsWith_(feature, inferenceSquaredErrorStr)
            || feature == exampleIdKey
            || this.facetDistFeatureNames.indexOf(feature) != -1;
      },

      /**
       * Creates a list of all feature values of the selected breakdown feature
       * or feature crosses if two breakdown features are selected, and gets
       * inference stats per breakdown.
       */
      breakdownFeatureSelected_: function() {
        // When features to slice by change, set optimization strategy
        // back to custom (default).
        this.resetOptimizationSelected_();

        const feature1 = this.selectedBreakdownFeature;
        if (feature1 == '') {
          this.selectedSecondBreakdownFeature = '';
        }
        const feature2 = this.selectedSecondBreakdownFeature;
        const thresholds = [];
        const thresholdsMap = {};
        if (feature1.length !== 0) {
          let feature1Values = this.stats[feature1].valueHash;
          // Only breakdown performance by features that don't contain fully-
          // unique values per example.
          if (this.stats[feature1].totalCount !=
              this.examplesAndInferences.length) {
            feature1Values  = Object.assign({}, feature1Values,
                {undefined: ''});
          }
          let feature2Values = {undefined: ''};
          if (feature2.length != 0) {
            feature2Values = this.stats[feature2].valueHash;
            if (this.stats[feature2].totalCount !=
                this.examplesAndInferences.length) {
              feature2Values  = Object.assign({}, feature2Values,
                  {undefined: ''});
            }
          }

          // For the selected feature, set up a dict of each feature value in
          // the dataset to the threshold. Add this to a list (for display
          // purposes) and create a map of feature value to entry in that list.
          for (var key1 in feature1Values) {
            if (feature1Values.hasOwnProperty(key1)) {
              for (var key2 in feature2Values) {
                if (feature2Values.hasOwnProperty(key2)) {
                  const feature1Value = key1 == 'undefined'
                    ? undefined : this.stats[feature1].valueHash[key1].value;
                  const feature2Value = key2 == 'undefined'
                    ? undefined : this.stats[feature2].valueHash[key2].value;
                  // Deep copy thresholds for each facet
                  const modelThresholds = []
                  for (let i = 0; i < this.overallThresholds.length; i++) {
                    modelThresholds.push(
                      {threshold: this.overallThresholds[i].threshold});
                  }
                  const thresh = {value: feature1Value, value2: feature2Value,
                                  threshold: modelThresholds, opened: false};
                  thresholds.push(thresh);
                  const mapKey = this.createCombinedValueString_(
                    feature1Value, feature2Value);
                  thresholdsMap[mapKey] = thresh;
                }
              }
            }
          }
        }
        this.set('featureValueThresholds', thresholds);
        this.set('featureValueThresholdsMap', thresholdsMap);
        this.refreshInferences_(false);
      },

      labelFeatureSelected_: function(feature) {
        // When the true label feature is selected, update inference stats.
        requestAnimationFrame(() => {
          this.updateInferenceStats_(true);
          this.refreshDive_();
        });
      },

      sideTabSelectedChanged_: function(tab) {
        if (tab == 1) {
          requestAnimationFrame(() => {
            this.updateInferenceStats_(true);
          });
        } else if (tab == 2) {
          // Force redraw of facets overview tables to ensure proper sizing.
          const tables = this.$.overview.querySelectorAll('facets-overview-table');
          for (let i = 0; i < tables.length; i++) {
            tables[i]._handleResize();
          }
        }
      },

      /**
       * Updates inference statistics, including breakdown stats if breakdown
       * features are selected, and updates visuals for those performance
       * stats.
       */
      updateInferenceStats_: function(regenInferenceStats) {
        // In the case user changes the number of models without refreshing
        // the page:
        // - The code may enter updateInferenceStats before
        // examplesAndInferences is updated for the correct number of models
        // - This may get called without regenInferenceStats, but
        // inferenceStats still contains the results for the old number of
        // models
        if (!this.inferenceStats_ || !this.visdata ||
            this.selectedLabelFeature == '' ||
            this.examplesAndInferences.length == 0 ||
            this.examplesAndInferences[0].inferences == null ||
            this.examplesAndInferences[0].inferences[0].length
              != this.numModels ||
            (this.inferenceStats_.length != this.numModels &&
              !regenInferenceStats)) {
          return;
        }
        if (regenInferenceStats) {
          const inferenceStatsArray = [];
          let regressionEntries = [];
          for (let modelInd = 0; modelInd < this.numModels;
              modelInd++) {
            let inferenceStats = {};
            if (this.isBinaryClassification_(this.modelType, this.multiClass)) {
              // For binary classifiers, update the confusion matrices values
              // for all possible classification thresholds.
              inferenceStats.thresholds = [];
              for (let i = 0; i < 101; i++) {
                inferenceStats.thresholds.push(
                  {'TP': 0, 'FP': 0, 'FN': 0, 'TN': 0});
              }
              inferenceStats.faceted = {};
              for (let i = 0; i < this.examplesAndInferences.length; i++) {
                const item = this.visdata[i];
                let facetedStats = null;
                if (this.selectedBreakdownFeature != '') {
                  const facetKey = this.createCombinedValueString_(
                    item[this.selectedBreakdownFeature],
                    item[this.selectedSecondBreakdownFeature]);
                  facetedStats = inferenceStats.faceted[facetKey];
                  if (!facetedStats) {
                    inferenceStats.faceted[facetKey] = []
                    for (let i = 0; i < 101; i++) {
                      inferenceStats.faceted[facetKey].push(
                          {'TP': 0, 'FP': 0, 'FN': 0, 'TN': 0});
                    }
                    facetedStats = inferenceStats.faceted[facetKey];
                  }
                }
                const nonZeroClassification =
                  this.getClassificationBestNonZero(i, modelInd);
                let thresh = 0;
                for (; thresh <= 100; thresh++) {
                  if (thresh > nonZeroClassification.score * 100) {
                    break;
                  }
                  if (+item[this.selectedLabelFeature] ==
                      +nonZeroClassification.label) {
                    inferenceStats.thresholds[thresh]['TP'] += 1;
                    if (facetedStats) {
                      facetedStats[thresh]['TP'] += 1;
                    }
                  } else {
                    inferenceStats.thresholds[thresh]['FP'] += 1;
                    if (facetedStats) {
                      facetedStats[thresh]['FP'] += 1;
                    }
                  }
                }
                for (; thresh <= 100; thresh++) {
                  if (item[this.selectedLabelFeature] == null ||
                      +item[this.selectedLabelFeature] == 0) {
                    inferenceStats.thresholds[thresh]['TN'] += 1;
                    if (facetedStats) {
                      facetedStats[thresh]['TN'] += 1;
                    }
                  } else {
                    inferenceStats.thresholds[thresh]['FN'] += 1;
                    if (facetedStats) {
                      facetedStats[thresh]['FN'] += 1;
                    }
                  }
                }
              }
              // For binary classification, no need to specify all possible
              // labels for the confusion matrices as the data contains both
              // classes.
              this.allConfMatrixLabels = [];

              this.calcThresholdStats(inferenceStats.thresholds);
              for(let key in inferenceStats.faceted) {
                if (inferenceStats.faceted.hasOwnProperty(key)) {
                  this.calcThresholdStats(inferenceStats.faceted[key]);
                }
              }
            } else if (this.isMultiClass_(this.modelType, this.multiClass)) {
              // For multi-class classifiers, update the confusion matrices.
              inferenceStats.results = {};
              inferenceStats.faceted = {};
              const allLabels = new Set();
              for (let i = 0; i < this.examplesAndInferences.length; i++) {
                const item = this.visdata[i];
                let facetedStats = null;
                if (this.selectedBreakdownFeature != '') {
                  const facetKey = this.createCombinedValueString_(
                    item[this.selectedBreakdownFeature],
                    item[this.selectedSecondBreakdownFeature]);
                  facetedStats = inferenceStats.faceted[facetKey];
                  if (!facetedStats) {
                    inferenceStats.faceted[facetKey] = {};
                    facetedStats = inferenceStats.faceted[facetKey];
                  }
                }
                let statsActual =
                  inferenceStats.results[item[this.selectedLabelFeature]];
                if (!statsActual) {
                  inferenceStats.results[item[this.selectedLabelFeature]] = {};
                  statsActual =
                    inferenceStats.results[item[this.selectedLabelFeature]];
                }
                const modelInferenceValueStr =
                  this.strWithModelName_(inferenceValueStr, modelInd);
                let count = statsActual[item[modelInferenceValueStr]];
                allLabels.add(String(item[modelInferenceValueStr]));
                allLabels.add(String(item[this.selectedLabelFeature]));
                if (count == null) {
                  statsActual[item[modelInferenceValueStr]] = 1;
                } else {
                  statsActual[item[modelInferenceValueStr]] += 1;
                }
                if (facetedStats) {
                  let statsActual =
                    facetedStats[item[this.selectedLabelFeature]];
                  if (!statsActual) {
                    facetedStats[item[this.selectedLabelFeature]] = {};
                    statsActual = facetedStats[item[this.selectedLabelFeature]];
                  }
                  let count = statsActual[item[modelInferenceValueStr]];
                  if (count == null) {
                    statsActual[item[modelInferenceValueStr]] = 1;
                  } else {
                    statsActual[item[modelInferenceValueStr]] += 1;
                  }
                }
              }
              this.allConfMatrixLabels = Array.from(allLabels.values());
            } else {
              // For regression models, calculate inference error.
              inferenceStats.results = {errors: []};
              inferenceStats.faceted = {};
              for (let i = 0; i < this.examplesAndInferences.length; i++) {
                const item = this.visdata[i];
                let facetedStats = null;
                if (this.selectedBreakdownFeature != '') {
                  const facetKey = this.createCombinedValueString_(
                    item[this.selectedBreakdownFeature],
                    item[this.selectedSecondBreakdownFeature]);
                  facetedStats = inferenceStats.faceted[facetKey];
                  if (!facetedStats) {
                    inferenceStats.faceted[facetKey] = {errors: []};
                    facetedStats = inferenceStats.faceted[facetKey];
                  }
                }
                const inferenceError =
                  item[this.strWithModelName_(inferenceValueStr, modelInd)] -
                   item[this.selectedLabelFeature];
                inferenceStats.results.errors.push(inferenceError);
                if (facetedStats) {
                  facetedStats.errors.push(inferenceError);
                }
              }
              regressionEntries.push(
                this.fillInRegressionStats(inferenceStats.results,
                  this.formatChartKey('All datapoints', modelInd, this.numModels)));
              for (let key in inferenceStats.faceted) {
                regressionEntries.push(
                  this.fillInRegressionStats(inferenceStats.faceted[key],
                    this.formatChartKey(key, modelInd, this.numModels)));
              }
            }
            inferenceStatsArray.push(inferenceStats);
          }
          regressionEntries = this.sortRegressionEntries(regressionEntries);
          this.regressionEntries_ = [];
          this.regressionEntries_ = regressionEntries;
          this.inferenceStats_ = inferenceStatsArray;
        }

        // Assigning to tempArray to force polymer to update the array.
        // Polymer does not recognize updates to elements within the array
        const tempArray = this.featureValueThresholds;
        this.featureValueThresholds = [];
        this.featureValueThresholds = this.sortFeatureValues(tempArray);

        // ROC curves should only exist for the binary case
        if (this.isBinaryClassification_(this.modelType, this.multiClass)) {
          for (let i = 0; i < this.featureValueThresholds.length; i++) {
            const plotStats = [];
            const plotThresholds = [];
            const modelThresholds = this.featureValueThresholds[i].threshold;
            for (let modelInd = 0; modelInd < modelThresholds.length;
              modelInd++) {
              const inferenceStats = this.inferenceStats_[modelInd];
              const key = this.createCombinedValueString_(
                this.featureValueThresholds[i].value,
                this.featureValueThresholds[i].value2);
              plotStats.push(inferenceStats.faceted[key]);
              plotThresholds.push(modelThresholds[modelInd].threshold)
            }
            this.plotChart(
              this.$$('#' + this.getRocChartId(i)),
              plotStats,
              plotThresholds,
              regenInferenceStats,
              true);
            this.plotChart(
              this.$$('#' + this.getPrChartId(i)),
              plotStats,
              plotThresholds,
              regenInferenceStats,
              false);
          }
          const plotStats = [];
          const plotThresholds = [];
          for (let modelInd = 0; modelInd < this.inferenceStats_.length;
            modelInd++) {
            plotStats.push(this.inferenceStats_[modelInd].thresholds);
            plotThresholds.push(this.overallThresholds[modelInd].threshold);
          }
          this.plotChart(
            this.$$('#rocchart'), plotStats,
            plotThresholds, regenInferenceStats, true);
          this.plotChart(
            this.$$('#prchart'), plotStats,
            plotThresholds, regenInferenceStats, false);
        }
        this.updateCorrectness_();
      },

      sortFeatureValues: function(values) {
        const inferenceStats = this.inferenceStats_[0];
        values = values.filter(a => {
          if (this.isRegression_(this.modelType)) {
            return this.getRegressionCount(inferenceStats, a) > 0
          } else if (this.isBinaryClassification_(
            this.modelType, this.multiClass)) {
            return this.getBinaryClassificationCount(inferenceStats, a) > 0
          } else {
            return this.getMulticlassClassificationCount(
              inferenceStats, a) > 0;
          }
        });
        return values.sort((a, b) => {
          if (this.selectedFeatureSort == 'Count') {
            if (this.isRegression_(this.modelType)) {
              return this.getRegressionCount(inferenceStats, b) -
                  this.getRegressionCount(inferenceStats, a);
            } else if (this.isBinaryClassification_(
              this.modelType, this.multiClass)) {
              return this.getBinaryClassificationCount(inferenceStats, b) -
                  this.getBinaryClassificationCount(inferenceStats, a);
            } else {
              return this.getMulticlassClassificationCount(
                inferenceStats, b) - this.getMulticlassClassificationCount(
                  inferenceStats, a);
            }
          } else if (this.selectedFeatureSort == 'Alphabetical') {
            return this.getPrintableValue_(a).localeCompare(this.getPrintableValue_(b));
          } else if (this.selectedFeatureSort == 'Accuracy') {
            if (this.isBinaryClassification_(this.modelType, this.multiClass)) {
              return +this.getAccuracyModelIndex(
                  this.inferenceStats_, b.threshold, 0, b) -
                +this.getAccuracyModelIndex(
                  this.inferenceStats_, a.threshold, 0, a)
            } else {
              return +this.getMultiClassAccuracyModelIndex(
                  this.inferenceStats_, 0, b) -
                +this.getMultiClassAccuracyModelIndex(
                  this.inferenceStats_, 0, a);
            }
          } else if (this.selectedFeatureSort == 'False positives') {
            return +this.getFPModelIndex(
                this.inferenceStats_, b.threshold, 0, b) -
              +this.getFPModelIndex(
                this.inferenceStats_, a.threshold, 0, a)
          } else if (this.selectedFeatureSort == 'False negatives') {
            return this.getFNModelIndex(
                +this.inferenceStats_, b.threshold, 0, b) -
              +this.getFNModelIndex(
                this.inferenceStats_, a.threshold, 0, a)
          }
        });
      },

      sortRegressionEntries: function(regressionEntries) {
        return regressionEntries.sort((a, b) => {
          if (this.selectedFeatureSort == 'Count') {
            return b.count - a.count;
          } else if (this.selectedFeatureSort == 'Alphabetical') {
            return a.name.localeCompare(b.name);
          } else if (this.selectedFeatureSort == 'Mean error') {
            return b.meanError - a.meanError;
          } else if (this.selectedFeatureSort == 'Mean absolute error') {
            return b.meanAbsError - a.meanAbsError;
          } else if (this.selectedFeatureSort == 'Mean squared error') {
            return b.meanSquaredError - a.meanSquaredError;
          }
        });
      },

      fillInRegressionStats: function(regressionStats, name) {
        // From initial regression stats having regression error per example,
        // calculate mean error, mean abs error, and mean squared error.
        function mean(data) {
          const sum = data.reduce((sum, value) => {
            return sum + value;
          }, 0);

          return sum / data.length;
        }

        const absErrors = regressionStats.errors.map(err => Math.abs(err));
        const squaredErrors = regressionStats.errors.map(err => err * err);

        return {
          name: name,
          meanError: mean(regressionStats.errors),
          meanAbsError: mean(absErrors),
          meanSquaredError: mean(squaredErrors),
          count: regressionStats.errors.length
        };
      },

      /**
       * Plots a PR or ROC purve given data to plot.
       * thresholdstats and thresholds are arrays, indexed by model number
       */
      plotChart: function(chart, thresholdStats, thresholds,
                       regenInferenceStats, isRoc) {
        if (!thresholdStats || !thresholdStats[0] || !chart) {
          return;
        }
        const visibleCharts = [];
        const seriesColors = [];
        const xAxis = isRoc ? 'FPR' : 'TPR';
        const yAxis = isRoc ? 'TPR' : 'PPV';
        const xAxisLabel = isRoc ? 'FPR' : 'Recall';
        const yAxisLabel = isRoc ? 'TPR' : 'Precision';
        for (let modelInd = 0; modelInd < thresholdStats.length; modelInd++) {
          let currentThresholdData = null;
          const data = thresholdStats[modelInd].map((thresh, i) => {
            // This finds the furthest point on the line that is below the
            // current threshold
            if (i - thresholds[modelInd] * 100 < 0.5) {
              currentThresholdData = {
                'step': thresh[xAxis],
                'scalar': thresh[yAxis],
                'threshold': i / 100
              };
            }
            return {
              'step': thresh[xAxis],
              'scalar': thresh[yAxis],
              'threshold': i / 100
            };
          }).reverse();
          chart.setSeriesData(
            this.strWithModelName_('Threshold set', modelInd),
            [currentThresholdData]);
          if (regenInferenceStats) {
            chart.setSeriesData(this.strWithModelName_('ROC', modelInd), data);
            visibleCharts.push(this.strWithModelName_('ROC', modelInd));
            visibleCharts.push(
              this.strWithModelName_('Threshold set', modelInd));
            seriesColors.push(this.rocCurveLineColors[modelInd]);
            seriesColors.push(this.rocCurveColors[modelInd]);
          }
        }
        if (regenInferenceStats) {
          const valueFormatter = d3.format('.2f');
          chart.xAxisFormatter = d3.format('.2f');
          const percentageFormatter = d3.format(",.1");
          const tooltipColumns = [
            {
                title: 'Threshold',
                evaluate: function (d) {
                  return valueFormatter(d.datum.threshold);
                },
            },
            {
                title: yAxisLabel,
                evaluate: function (d) {
                  return isRoc ? percentageFormatter(d.datum.scalar) :
                    valueFormatter(d.datum.scalar);
                },
            },
            {
                title: xAxisLabel,
                evaluate: function (d) {
                  return isRoc ? percentageFormatter(d.datum.step) :
                    valueFormatter(d.datum.step);
                },
            },
          ];
          // When more than one model is available, make tooltip show an extra
          // column for model id
          if (thresholdStats.length > 1){
            tooltipColumns.push(
              {
                title: 'Model',
                evaluate: function (d) {
                  const modelId = d.dataset.metadata().name.split(' ');
                  return modelId[modelId.length - 1];
                },
              }
            );
          }
          chart.tooltipColumns = tooltipColumns;
          chart.colorScale = new Plottable.Scales.Color().range(seriesColors);
          chart.colorScale.domain(visibleCharts);
          chart.setVisibleSeries(visibleCharts);
        }
      },

      /**
       * Calculates TPR, FPR, and PPV given binary confusion matrix counts.
       */
      calcThresholdStats: function(stats) {
        for (let i = 0; i < stats.length; i++) {
          if (stats[i]['TP'] + stats[i]['FN'] > 0) {
            stats[i]['TPR'] =
              stats[i]['TP'] / (stats[i]['TP'] + stats[i]['FN']);
          } else {
            stats[i]['TPR'] = 0;
          }
          if (stats[i]['FP'] + stats[i]['TN'] > 0) {
            stats[i]['FPR'] =
              stats[i]['FP'] / (stats[i]['FP'] + stats[i]['TN']);
          } else {
            stats[i]['FPR'] = 0;
          }
          if (stats[i]['TP'] + stats[i]['FP'] > 0) {
            stats[i]['PPV'] =
              stats[i]['TP'] / (stats[i]['TP'] + stats[i]['FP']);
          } else {
            stats[i]['PPV'] = 0;
          }
        }
      },

      /**
       * Runs the appropriate threshold optimizer.
       */
      optimizationSelectedChanged_: function(selection) {
        if (selection == 'custom') {
          return;
        }
        else if (selection == 'unaware') {
          this.optimizeThresholdClicked_();
        }
        else if (selection == 'group') {
          this.optimizeFacetedThresholdsClicked_();
        }
        else if (selection == 'demoparity') {
          this.demoParityClicked_();
        }
        else if (selection == 'equalacc') {
          this.equalAccClicked_();
        }
        else if (selection == 'equalopp') {
          this.equalOppoClicked_();
        }
      },

      costRatioChanged_: function() {
        // When cost ratio changes, set optimization strategy
        // back to custom (default).
        this.resetOptimizationSelected_();
      },

      resetOptimizationSelected_: function() {
        const button = this.$$('#customthresh');
        if (button != null) {
          button.click();
        }
      },

      optimizeThresholdClicked_: function() {
        // Find the optimal threshold for all examples, then set all thresholds
        // to that value.
        for (let modelInd = 0; modelInd < this.inferenceStats_.length;
            modelInd++) {
          const thresholdToSet =
            this.findOptimalThreshold_(
              this.inferenceStats_[modelInd].thresholds);
          this.set('overallThresholds.' + modelInd + '.threshold',
            thresholdToSet);
          if (this.featureValueThresholds) {
            for (let i = 0; i < this.featureValueThresholds.length; i++) {
              const thresholdPath = 'featureValueThresholds.' + i +
                '.threshold.' + modelInd + '.threshold';
              this.set(thresholdPath, thresholdToSet);
            }
          }
        }
      },

      optimizeFacetedThresholdsClicked_: function() {
        // For each faceted set of examples, find the optimal threshold and
        // set it.
        for (let modelInd = 0; modelInd < this.inferenceStats_.length;
            modelInd++) {
          const values = Object.keys(this.inferenceStats_[modelInd].faceted);
          for (let i = 0; i < values.length; i++) {
            const featureValue = values[i];
            const thresholdToSet = this.findOptimalThreshold_(
              this.inferenceStats_[modelInd].faceted[featureValue]);
            this.set('featureValueThresholds.' + i + '.threshold.' + modelInd +
              '.threshold', thresholdToSet);
          }
        }
      },

      /**
       * Returns an optimal threshold from all classification thresholds.
       */
       findOptimalThreshold_: function(thresholds) {
        let minCost = Number.POSITIVE_INFINITY;
        let bestThreshold = 0;
        for (let i = 0; i < thresholds.length; i++) {
          const cost = this.getCost(thresholds[i]);
          if (cost <= minCost) {
            minCost = cost;
            bestThreshold = i;
          }
        }
        return bestThreshold / 100;
      },


      equalOppoClicked_: function() {
        // Find the optimal thresholds while maintaining equal opportunity.
        const measure =
          stats => stats['TP'] / (stats['TP'] + stats['FN']);
        this.getBestThresholdsByFairnessMeasure_(measure);
      },

      equalAccClicked_: function() {
        // Find the optimal thresholds while maintaining equal accuracy.
        const measure =
          stats => (stats['TP'] + stats['TN']) /
            (stats['TP'] + stats['FP'] + stats['TN'] + stats['FN']);
        this.getBestThresholdsByFairnessMeasure_(measure);
      },

      demoParityClicked_: function() {
        // Find the optimal thresholds while maintaining demographic parity.
        const measure =
          stats => (stats['TP'] + stats['FP']) /
            (stats['TP'] + stats['FP'] + stats['TN'] + stats['FN']);
        this.getBestThresholdsByFairnessMeasure_(measure);
      },

      getBestThresholdsByFairnessMeasure_: function(fairnessCalculator) {
        // For all thresholds for first facet:
        //   For all other facets:
        //     Find threshold with closest fairness measure of first facet at
        //     current threshold
        //   Calculate cost for these threshold settings settings across the
        //   facets, and save if the lowest.
        for (let modelInd = 0; modelInd < this.inferenceStats_.length;
            modelInd++) {
          let minCost = Number.POSITIVE_INFINITY;
          let bestThresholds = null;
          const modelStats = this.inferenceStats_[modelInd];
          const values = Object.keys(modelStats.faceted);
          const firstFacet = modelStats.faceted[values[0]];
          for (let i = 0; i < firstFacet.length; i++) {
            const firstFacetMeasure = fairnessCalculator(firstFacet[i]);
            const facetThresholds = [i];
            let cost = this.getCost(firstFacet[i]);
            for (let facetIdx = 1; facetIdx < values.length; facetIdx++) {
              const currentFacet = modelStats.faceted[values[facetIdx]];
              const currentFacetThreshold = this.thresholdClosestToMeasure(
                currentFacet, firstFacetMeasure, fairnessCalculator);
              facetThresholds.push(currentFacetThreshold);
              cost += this.getCost(currentFacet[currentFacetThreshold])
            }
            if (cost <= minCost) {
              minCost = cost;
              bestThresholds = facetThresholds;
            }
          }

          // Set all thresholds to the setting with the lowest cost from the
          // above search.
          for (let vIdx = 0; vIdx < values.length; vIdx++) {
            this.set('featureValueThresholdsMap.' + values[vIdx] +
              '.threshold.' + modelInd + '.threshold',
              bestThresholds[vIdx] / 100 );
          }
          // Polymer does not reflect changes if we only update through
          // featureValueThresholdsMap, this is a quick workaround
          // until we find the correct way to link
          for (let i = 0; i < this.featureValueThresholds.length; i++) {
            const value =
                this.featureValueThresholds[i].threshold[modelInd].threshold;
            this.set('featureValueThresholds.' + i + '.threshold.' + modelInd +
              '.threshold', value);
          }
        }
      },

      /**
       * Returns the cost of a classification threshold given the incorrect
       * inferences and the ratio of cost of false positives vs false negatives.
       */
      getCost: function(entries) {
        return entries['FP'] * this.incorrectPredCostRatio + entries['FN'];
      },

      /**
       * Helper function for finiding best thresholds with fairness measures.
       */
      thresholdClosestToMeasure: function(
          currentFacet, firstFacetMeasure, fairnessCalculator) {
        let minDistance = Number.POSITIVE_INFINITY;
        let thresholdToReturn = 0;
        for (let i = 0; i < currentFacet.length; i++) {
          const measure = fairnessCalculator(currentFacet[i]);
          const curDistance = Math.abs(measure - firstFacetMeasure);
          if (curDistance <= minDistance) {
            thresholdToReturn = i;
            minDistance = curDistance;
          }
        }
        return thresholdToReturn;
      },

      /**
       * Finds the first inference label in the score-sorted list that is
       * non-zero.
       */
      getClassificationBestNonZero: function(index, modelIndex) {
        let indexForNonZeroLabel = 0;
        const inferenceIndex =
          this.examplesAndInferences[index].inferences.length - 1;
        for (let i = 0;
             i < this.examplesAndInferences[index].inferences[
               inferenceIndex][modelIndex].length;
             i++) {
          if (+this.examplesAndInferences[index].inferences[
              inferenceIndex][modelIndex][i].label !== 0) {
            indexForNonZeroLabel = i;
            break;
          }
        }
        return this.examplesAndInferences[index].inferences[
          inferenceIndex][modelIndex][indexForNonZeroLabel];
      },

      /**
       * Gets confusion counts for a single model index modelInd
       */
      getConfusionCountsModelIndex: function(inferenceStats, thresholds,
          modelInd, item) {
        // During updates inferenceStats and overallThresholds may get out of
        // sync, this if protects against indexing them before final state
        if (this.overallThresholds.length != this.numModels ||
            this.inferenceStats_.length != this.numModels) {
          return {};
        } else {
          return this.getConfusionCounts(this.inferenceStats_[modelInd],
            thresholds[modelInd].threshold, item);
        }
      },

      /**
       * Returns the total number of entries in a confusion matrix.
       */
      getTotalEntriesInConfCounts: function(counts) {
        if (counts == null) {
          return 0;
        }
        let total = 0;
        const outerKeys = Object.keys(counts);
        for (let i = 0; i < outerKeys.length; i++) {
          const inner = counts[outerKeys[i]];
          const innerKeys = Object.keys(inner);
          for (let j = 0; j < innerKeys.length; j++) {
            total += inner[innerKeys[j]];
          }
        }
        return total;
      },

      /**
       * Returns the false positive percentage for a given confusion matrix
       * from the threshold selected, model index, and facet to view.
       */
      getFPModelIndex: function (inferenceStats, thresholds, modelInd, item) {
        // TODO(jameswex): This unnecessarily recalculates confusion matrix.
        // Can speed this up.
        const confCounts = this.getConfusionCountsModelIndex(
          inferenceStats, thresholds, modelInd, item);
        if (Object.keys(confCounts).length == 0) {
          return null;
        }
        const val = confCounts['No']['Yes'];
        return d3.format(",.1f")(
          val / this.getTotalEntriesInConfCounts(confCounts) * 100);
      },

      /**
       * Returns the false negative percentage for a given confusion matrix
       * from the threshold selected, model index, and facet to view.
       */
      getFNModelIndex: function(inferenceStats, thresholds, modelInd, item) {
        // TODO(jameswex): This unnecessarily recalculates confusion matrix.
        // Can speed this up.
        const confCounts = this.getConfusionCountsModelIndex(
          inferenceStats, thresholds, modelInd, item);
        if (Object.keys(confCounts).length == 0) {
          return 0;
        }
        const val = confCounts['Yes']['No'];
        return d3.format(",.1f")(
          val / this.getTotalEntriesInConfCounts(confCounts) * 100);
      },


      /**
       * Returns the accuracy percentage for a given confusion matrix
       * from the threshold selected, model index, and facet to view.
       */
      getAccuracyModelIndex: function(inferenceStats, thresholds, modelInd, item) {
        // TODO(jameswex): This unnecessarily recalculates confusion matrix.
        // Can speed this up.
        const confCounts = this.getConfusionCountsModelIndex(
          inferenceStats, thresholds, modelInd, item);
        if (Object.keys(confCounts).length == 0) {
          return 0;
        }
        const val = confCounts['Yes']['Yes'] + confCounts['No']['No'];
        return d3.format(",.1f")(
          val / this.getTotalEntriesInConfCounts(confCounts) * 100);
      },

      /**
       * Returns the F1 score for a given confusion matrix
       * from the threshold selected, model index, and facet to view.
       */
       getF1ModelIndex: function(inferenceStats, thresholds, modelInd, item) {
        // TODO(jameswex): This unnecessarily recalculates confusion matrix.
        // Can speed this up.
        const formatter = d3.format(",.2f");
        const confCounts = this.getConfusionCountsModelIndex(
          inferenceStats, thresholds, modelInd, item);
        if (Object.keys(confCounts).length == 0) {
          return 0;
        }
        const truePositives = confCounts['Yes']['Yes'];
        const falsePositives = confCounts['No']['Yes'];
        const falseNegatives = confCounts['Yes']['No'];
        if (truePositives == 0) {
          if (falsePositives != 0 || falseNegatives != 0) {
            return formatter(0);
          } else {
            return formatter(1);
          }
        }
        const precision = truePositives / (truePositives + falsePositives);
        const recall = truePositives / (truePositives + falseNegatives);
        return formatter(
          2 * (precision * recall) / (precision + recall));
      },

      /**
       * Returns the number of examples in a given facet.
       */
      getFeatureValueCount: function(inferenceStats, thresholds, item) {
        // TODO(jameswex): This unnecessarily recalculates confusion matrix.
        // Can speed this up.
        const confCounts = this.getConfusionCountsModelIndex(
          inferenceStats, thresholds, 0, item);
        return this.getTotalEntriesInConfCounts(confCounts);
      },

      /**
       * Returns the label of a confusion matrix for a given model index.
       * When only using 1 model, no label is needed.
       */
      getConfusionMatrixLabel: function(index, numModels) {
        if (numModels < 2) {
          return '';
        }
        return this.getModelName_(index);
      },

      /**
       * Returns the background color of a confusion matrix based on
       * model index.
       */
      getConfusionMatrixColor: function(index) {
        return this.confMatrixColors[index]
      },

      /**
       * Gets binary confusion matrix counts from inference results.
       */
      getConfusionCounts(inferenceStats, threshold, item) {
        let val = null;
        let val2 = null;
        if (item != null) {
          val = item.value;
          val2 = item.value2;
        }
        return {
          'No': {
            'No': this.getConfMatrixValue(inferenceStats, threshold, 'TN', val,
                                       val2),
            'Yes': this.getConfMatrixValue(inferenceStats, threshold, 'FP', val,
                                       val2)
          },
          'Yes': {
            'No': this.getConfMatrixValue(inferenceStats, threshold, 'FN', val,
                                       val2),
            'Yes': this.getConfMatrixValue(inferenceStats, threshold, 'TP', val,
                                      val2)
          }
        };
      },

      /**
       * Helper method for getConfusionCounts
       */
      getConfMatrixValue: function(inferenceStats, threshold, stat,
          featureValue1, featureValue2) {
        const index = Math.floor(threshold * 100)
        if (!inferenceStats.thresholds) {
          return 0;
        }
        if (featureValue1 === null) {
          return inferenceStats.thresholds[index][stat];
        }
        const key =
          this.createCombinedValueString_(featureValue1, featureValue2);
        if (inferenceStats.faceted[key] == null) {
          return 0;
        }
        return inferenceStats.faceted[key][index][stat];
      },

      /**
       * Gets multi-class confusion matrix from inference stats.
       */
      getMultiClassConfMatrix: function(inferenceStats, modelInd, facetItem) {
        if (inferenceStats.length == 0) {
          return {};
        } else if (facetItem == null) {
          return inferenceStats[modelInd].results;
        } else {
          const key = this.getPrintableValue_(facetItem);
          return inferenceStats[modelInd].faceted[key];
        }
      },


      /**
       * Returns the number of examples in a given facet from a
       * multi-class confusion matrix.
       */
      getMultiClassFeatureValueCount: function(inferenceStats, facetItem) {
        const confCounts = this.getMultiClassConfMatrix(inferenceStats, 0, facetItem);
        return this.getTotalEntriesInConfCounts(confCounts);
      },

      /**
       * Returns the accuracy percentage for a given multi-class confusion
       * matrix from the threshold selected, model index, and facet to view.
       */
      getMultiClassAccuracyModelIndex: function(
          inferenceStats, modelInd, facetItem) {
        const confCounts = this.getMultiClassConfMatrix(
          inferenceStats, modelInd, facetItem);
        if (confCounts == null) {
          return null;
        }
        let matches = 0;
        const outerKeys = Object.keys(confCounts);
        for (let i = 0; i < outerKeys.length; i++) {
          const inner = confCounts[outerKeys[i]];
          const innerKeys = Object.keys(inner);
          for (let j = 0; j < innerKeys.length; j++) {
            if (outerKeys[i] == innerKeys[j]) {
              matches += inner[innerKeys[j]];
            }
          }
        }
        return d3.format(",.1f")(
          matches / this.getTotalEntriesInConfCounts(confCounts) * 100);
      },

      /**
       * Gets a inference statistic from inference results.
       */
      getInferenceStat: function(inferenceStats, facetItem, getter,
          formatter) {
        const stats = facetItem
            ? inferenceStats.faceted[this.getPrintableValue_(facetItem)]
            : inferenceStats.results;
        if (!stats) {
          return null;
        }
        const val = getter(stats);
        if (!formatter) {
          return val;
        } else {
          return formatter(val);
        }
      },

      getRegressionMean: function(regressionStats, facetItem) {
        return this.getInferenceStat(regressionStats, facetItem,
          stat => stat.mean, d3.format('.3f'));
      },

      getRegressionAbsMean: function(regressionStats, facetItem) {
        return this.getInferenceStat(regressionStats, facetItem,
          stat => stat.absMean, d3.format('.3f'));
      },

      getRegressionSquaredMean: function(regressionStats, facetItem) {
        return this.getInferenceStat(regressionStats, facetItem,
          stat => stat.squaredMean, d3.format('.3f'));
      },

      getRegressionCount: function(regressionStats, facetItem) {
        const count = this.getInferenceStat(regressionStats, facetItem,
          stat => stat.errors.length, null);
        if (count == null) {
          return 0;
        } else {
          return count;
        }
      },

      getBinaryClassificationCount: function(classificationStats, facetItem) {
        // stat[0] because we only need to count one threshold in binary case
        return this.getInferenceStat(classificationStats, facetItem,
          stat => Object.values(stat[0]).reduce((a, b) => a + b), null);
      },

      getMulticlassClassificationCount: function(classificationStats,
          facetItem) {
        // stat because in multi class case inferenceStats does not have
        // thresholds
        return this.getInferenceStat(classificationStats, facetItem,
          stat => Object.values(stat).reduce(
            (a, b) => {
              let total = 0;
              const iKeys = Object.keys(b);
              for (let i = 0; i < iKeys.length; i++) {
                total += b[iKeys[i]];
              }
              return a + total;
            }, 0), null);
      },

      getRocChartId: function(index) {
        return 'rocchart' + index;
      },

      getPrChartId: function(index) {
        return 'prchart' + index;
      },

      /**
       * Returns a printable value for a breakdown item, meaning performance
       * statistics broken down by feature values or feature crosses.
       */
      getPrintableValue_: function(item) {
        let str = '';
        if (!item.value && item.value !== 0) {
          str = '<feature value missing>';
        } else {
          str = String(item.value);
        }
        if (this.selectedSecondBreakdownFeature == '') {
          return str;
        }
        str += '/';
        if (!item.value2 && item.value2 !== 0) {
          str += '<feature value missing>';
        } else {
          str += item.value2;
        }
        return str;

      },

      getFeatureName_: function(feature) {
        // If feature name is blank then this represents selecting no feature.
        if (feature.length === 0) {
          return '<none>';
        }
        return feature;
      },

      getCounterfactualModelName_: function(modelName) {
        return 'Model: ' + modelName;
      },

      getClassName_: function(cls) {
        // If class name is blank then this represents selecting no class.
        if (cls.length === 0) {
          return '<none>';
        }
        return cls;
      },

      shouldShowOverallThresholder_: function(feature) {
        return feature.length === 0;
      },

      /**
       * Sets the selected example from the facets dive selection.
       */
      computeSelectedExampleAndInference: function() {
        this.counterfactualExampleAndInference = null;
        if (!this.selected || !this.examplesAndInferences) {
          this.selectedExampleAndInference = null;
          return;
        }
        this.selectedExampleAndInference =
          this.selected.length > 0
          ? this.examplesAndInferences[this.selected[0]] : null;
        if (this.selectedExampleAndInference == null) {
          this.globalPdPlots = true;
        } else {
          this.globalPdPlots = false;
          if (this.visMode != 'dive') {
            this.showPartialDependencePlots_();
          }
        }
      },

      /**
       * Finds attribution features and sets the attribution object for the
       * selected example.
       */
      setAttributions: function() {
        const attrib = {};
        const selectedData = this.visdata[this.selected[0]];
        const attributionFinder = new RegExp(attributionPrefix + '(.*)');
        const sparseAttributionFinder =
            new RegExp(attributionPrefix + '(.*)' + attributionSparseKeySuffix);
        for (let key in selectedData) {
          let featureWithAttribution = attributionFinder.exec(key);
          // If this feature represents an attribution, set the attribution
          // value for the appropriate example feature.
          // Attribution is represented by features with the format
          // "{attributionPrefix}{featureName}".
          if (featureWithAttribution) {
            const featFinder = new RegExp(
              '^(' + featureForAttributionPrefix + ')?' +
              featureWithAttribution[1] + '$');
            for (let featToTest in selectedData) {
              if (featFinder.test(featToTest)) {
                attrib[featToTest] = selectedData[key];
                break;
              }
            }
          }
          featureWithAttribution = sparseAttributionFinder.exec(key);
          // If this feature represents a sparse attribution, set the
          // attribution values for the appropriate example feature.
          // "{attributionPrefix}{featureName}{attributionSparseKeySuffix}"
          // containing a list of feature values for which we have attribution
          // values and
          // "{attributionPrefix}{featureName}{attributionSparseValueSuffix}"
          // containing a same-sized list of attribution amounts for those
          // feature values.
          if (featureWithAttribution) {
            const featFinder = new RegExp(
              '^(' + featureForAttributionPrefix + ')?' +
              featureWithAttribution[1] + '$');
            for (let featToTest in selectedData) {
              if (featFinder.test(featToTest)) {
                const attribKeys = selectedData[key];
                const attribVals = selectedData[key.replace(
                  attributionSparseKeySuffix, attributionSparseValueSuffix)];
                const len = Array.isArray(selectedData[featToTest]) ?
                      selectedData[featToTest].length : 1;
                const attribList = Array.apply(null, Array(len)).map(
                  Number.prototype.valueOf, 0);
                for (let attribIdx = 0; attribIdx < attribKeys.length;
                     attribIdx++) {
                  let valIndex = selectedData[featToTest].indexOf(
                    attribKeys[attribIdx]);
                  if (valIndex != -1) {
                    attribList[valIndex] = attribVals[attribIdx];
                  }
                }
                attrib[featToTest] = attribList;
                break;
              }
            }
          }
        }
        this.attribution = attrib;
      },

      shouldDisableGetExamplesButton_: function(examplesPath) {
        return examplesPath.length == 0;
      },

      shouldDisableInferButton_: function(examples, modelName, inferenceAddress,
          updatedExample) {
        return examples.length == 0 || modelName.length == 0 ||
          inferenceAddress.length == 0 || !updatedExample;
      },

      areExamplesEditable_: function(modelName, inferenceAddress) {
        return modelName.length != 0 && inferenceAddress.length != 0;
      },

      newInferences_: function() {
        this.$.spinner.hidden = true;
        this.updateInferences_(true);
        requestAnimationFrame(() => this.updateInferenceStats_(true));
      },

      refreshInferencesNoRegen_: function() {
        this.refreshInferences_(true);
        requestAnimationFrame(() => this.updateInferenceStats_(true));
      },

      refreshInferences_: function(noRegen) {
        this.updateInferences_(false);
        requestAnimationFrame(() => this.updateInferenceStats_(!noRegen));
      },

      /**
       * Updates inference results.
       */
      updateInferences_: function(newInferencesCalculated) {
        if (!this.examplesAndInferences || !this.inferences.indices ||
            this.inferences.indices.length == 0 ||
            this.inferences.results.length != this.numModels) {
          return;
        }
        // Create map of example indices to inference results.
        // inferenceMap: sample id -> # Models -> # Labels
        const inferenceMap = {}
        const isClassification =
          !!this.inferences.results[0].classificationResult;
        for (let i = 0; i < this.inferences.indices.length; i++) {
          if (isClassification) {
            inferenceMap[this.inferences.indices[i]] = [];
            for (let modelNum = 0; modelNum < this.inferences.results.length;
                 modelNum++){
              const result =
                this.inferences.results[modelNum].classificationResult;
              // For models that don't return any labels for the classes, fill
              // them out with class indices.
              for (let j = 0; j < result.classifications[i].classes.length;
                  j++) {
                if (result.classifications[i].classes[j].label == '') {
                  result.classifications[i].classes[j].label = j.toString();
                }
              }
              inferenceMap[this.inferences.indices[i]][modelNum] =
                  result.classifications[i].classes.sort(
                    (a, b) => b.score - a.score);
            }
          } else {
            inferenceMap[this.inferences.indices[i]] = [];
            for (let modelNum = 0; modelNum < this.inferences.results.length;
              modelNum++) {
              const result = this.inferences.results[modelNum].regressionResult;
              inferenceMap[this.inferences.indices[i]][modelNum] =
                [{ label: '', score: result.regressions[i].value }];
            }
          }
        }
        // Set the inferences in the examplesAndInferences structure, updating
        // for new inferences where appropriate.
        this.set('examplesAndInferences', this.examplesAndInferences.map(
          function(item, index) {
            let inferences = item.inferences ? item.inferences : [];
            if (inferenceMap[index] && newInferencesCalculated) {
              inferences = inferences.concat([inferenceMap[index]]);
            }
            return {example: item.example, inferences: inferences,
                    changed: item.changed, orig: item.orig};
          }));
        const self = this;
        let hasInferenceLabels = false;
        this.visdata.forEach(function(item, index) {
          if (isClassification) {
            self.setItemInferenceValue(
              item, index, self.selectedBreakdownFeature,
              self.selectedSecondBreakdownFeature);
          } else {
            for (let modelInd = 0; modelInd < self.numModels;
                 modelInd++) {
              item[self.strWithModelName_(inferenceValueStr, modelInd)] =
                self.examplesAndInferences[index].inferences[
                  self.examplesAndInferences[index].inferences.length - 1][
                  modelInd][0].score;
            }
          }

          // If there is a label vocab for classification, set the string
          // inferred label for each example.
          if (isClassification && self.labelVocab.length > 0) {
            for (let inferenceIndex = 0;
                 inferenceIndex <
                 self.examplesAndInferences[index].inferences.length;
                 inferenceIndex++) {
              for (let modelNum = 0;
                   modelNum < self.examplesAndInferences[index].inferences[
                    inferenceIndex].length;
                   modelNum++) {
                for (let labelIndex = 0;
                    labelIndex < self.examplesAndInferences[index].inferences[
                      inferenceIndex][modelNum].length;
                    labelIndex++) {
                  self.examplesAndInferences[index].inferences[
                    inferenceIndex][modelNum][
                      labelIndex].vocabLabel = self.labelVocab[
                      self.examplesAndInferences[index].inferences[
                        inferenceIndex][modelNum][labelIndex].label];
                }
              }
            }
            for (let modelInd = 0; modelInd < self.numModels; modelInd++) {
              item[self.strWithModelName_(inferenceLabelStr, modelInd)] =
                self.labelVocab[
                  item[self.strWithModelName_(inferenceValueStr, modelInd)]];
            }
            hasInferenceLabels = true;
          }
        });
        this.updateCorrectness_();
        this.refreshDive_();

        // If inferring for the first time, set the color in facets dive to
        // inference results of the first model and use positioning to show
        // inference scores. When reinferring from changes, don't override
        // whatever options have been set.
        if (this.inferences.indices.length ==
            this.examplesAndInferences.length) {
          this.$.dive.colorBy =
            hasInferenceLabels ? this.strWithModelName_(inferenceLabelStr, 0)
              : this.strWithModelName_(inferenceValueStr, 0);
          if (this.isRegression_(this.modelType)) {
            this.$.dive.horizontalPosition = this.strWithModelName_(inferenceValueStr, 0);
          }
          else if (this.isBinaryClassification_(this.modelType, this.multiClass)) {
            if (this.numModels == 1) {
              this.$.dive.verticalPosition = this.strWithModelName_(inferenceScoreStr, 0);
            } else {
              this.$.dive.horizontalPosition = this.strWithModelName_(inferenceScoreStr, 0);
              this.$.dive.verticalPosition = this.strWithModelName_(inferenceScoreStr, 1);
            }
          }
        }
        this.updatedExample = false;
      },

      newAttributions_: function(attributions) {
        if (Object.keys(attributions).length == 0) {
          return;
        }
        for (let i = 0; i < attributions.indices.length; i++) {
          const idx = attributions.indices[i];
          const datapoint = Object.assign({}, this.visdata[idx]);
          // TODO(jwexler): Support attributions from multiple models.
          // For now, we only display attribution from the first model, if WIT
          // is loaded with two models.
          const attribs = attributions.attributions[0][i];
          const keys = Object.keys(attribs);
          for (let j = 0; j < keys.length; j++) {
            // If the attributions for a key is a 2D array then treat the first
            // entry as sparse keys for attributions and the second entry as
            // the attributions for the sparse keys in the first array.
            // Otherwise the attribution is a single value or list and can be
            // used as such.
            if (Array.isArray(attribs[keys[j]]) &&
                attribs[keys[j]].length == 2 &&
                Array.isArray(attribs[keys[j]][0])) {
              const attribSparseKeyKey = attributionPrefix + keys[j] +
                attributionSparseKeySuffix;
              datapoint[attribSparseKeyKey] = attribs[keys[j]][0];
              const attribSparseValueKey = attributionPrefix + keys[j] +
                attributionSparseValueSuffix;
              datapoint[attribSparseValueKey] = attribs[keys[j]][1];
            } else {
              const attribKey = attributionPrefix + keys[j];
              datapoint[attribKey] = attribs[keys[j]];
            }
          }
          this.set(`visdata.${idx}`, datapoint);
        }
        this.setAttributions();
        this.refreshDive_();
      },

      /**
       * Helper method for setting inference value for classifications.
       */
      setItemInferenceValue: function(item, index, feature1, feature2) {
        const inferenceIdx =
          this.examplesAndInferences[index].inferences.length - 1;
        if (this.multiClass) {
          for (let i = 0; i < this.numModels; i++){
            item[this.strWithModelName_(inferenceValueStr, i)] =
            this.examplesAndInferences[index].inferences[inferenceIdx][i][
              0].label;
          }
          return;
        }

        // Binary classifier case.
        let thresholds = this.overallThresholds;
        // If a feature has been selected (string will be non-empty in this
        // case), then get the appropriate threshold for this item's value for
        // that feature. Otherwise the overall threshold will be used.
        if (feature1.length !== 0) {
          let key =
            this.createCombinedValueString_(item[feature1], item[feature2]);
          thresholds = this.featureValueThresholdsMap[key].threshold;
        }
        for (let modelNum = 0; modelNum < this.numModels; modelNum++){
          const nonZeroClassification =
            this.getClassificationBestNonZero(index, modelNum);
          item[this.strWithModelName_(inferenceScoreStr, modelNum)] =
            nonZeroClassification.score;
          if (nonZeroClassification.score >= thresholds[modelNum].threshold) {
            item[this.strWithModelName_(inferenceValueStr, modelNum)] =
              nonZeroClassification.label;
          } else {
            item[this.strWithModelName_(inferenceValueStr, modelNum)] =
              this.defaultInferenceLabel.toString();
          }
        }
      },

      createCombinedValueString_: function(val1, val2) {
        let str = val1 == null ? '' : val1;
        if (val2 == null || val2 == '') {
          return str;
        }
        str += '/' + val2;
        return str;
      },

      /**
       * Updates per-item results for display in facets dive based on inference.
       */
      updateCorrectness_: function() {
        if (!this.selectedLabelFeature || !this.examplesAndInferences) {
          return;
        }
        for (let i = 0; i < this.examplesAndInferences.length; i++) {
          const item = this.visdata[i];
          for (let modelInd = 0; modelInd < this.numModels;
              modelInd++){
            if (this.modelType == 'classification') {
              item[this.strWithModelName_(inferenceCorrectStr, modelInd)] =
                item[this.selectedLabelFeature] ==
                  item[this.strWithModelName_(inferenceValueStr, modelInd)]
                    ? "correct" : "incorrect";
            } else {
              item[this.strWithModelName_(inferenceErrorStr, modelInd)] =
                item[this.strWithModelName_(inferenceValueStr, modelInd)] -
                  item[this.selectedLabelFeature];
              item[this.strWithModelName_(inferenceAbsErrorStr, modelInd)] =
                Math.abs(
                  item[this.strWithModelName_(inferenceErrorStr, modelInd)]);
              item[this.strWithModelName_(inferenceSquaredErrorStr,
               modelInd)] =
                item[this.strWithModelName_(inferenceErrorStr, modelInd)] *
                 item[this.strWithModelName_(inferenceErrorStr, modelInd)];
            }
          }
        }
      },

      /**
       * Handler for when running inference, calls the backend.
       */
      inferClicked_: function() {
        const inferParams = {'inference_address': this.inferenceAddress,
                             'model_name': this.modelName,
                             'model_type': this.modelType,
                             'model_version': this.modelVersion,
                             'model_signature': this.modelSignature,
                             'label_vocab_path': this.labelVocabPath,
                             'use_predict': this.usePredictApi,
                             'predict_output_tensor': this.predictOutputTensor,
                             'predict_input_tensor': this.predictInputTensor};
        this.$.spinner.hidden = false;
        if (!this.local) {
          const url = this.makeUrl_('/data/plugin/whatif/infer',
              inferParams);
          const inferContents = result => {
            this.$.spinner.hidden = true;
            this.labelVocab = /** @type {!Array} */ (JSON.parse(result.value.vocab));
            this.inferences = /** @type {!Object} */ (JSON.parse(result.value.inferences));
          };
          this.makeAsyncRequest_(url, inferContents, null);
        }
        this.fire('infer-examples', inferParams);
      },

      /**
       * Handler for an example being changed by user input.
       */
      exampleChange_: function(event) {
        var id = 0;
        var index = this.selected.length == 0 ? id : this.selected[id];
        this.set('selectedExampleAndInference.changed', true);
        this.updateExample_(JSON.stringify(event.target.json), index);
        const inferenceViewerIdStr = '#' + this.getInferenceHolderId_();
        const inferenceViewer = this.$$(inferenceViewerIdStr);
        inferenceViewer.inference = null;
        this.visdata[index] =
          this.exampleToDataPoint_(event.target.json, index);
        this.showNearestCounterfactual = false;
        this.refreshDive_();
        this.updatedExample = true;
        this.selectedDataUpdated_();
      },

      refreshDiveImpl_: function() {
        const temp = this.visdata;
        this.visdata = [];
        this.visdata = temp;
        this.selectedExampleMax = this.visdata.length - 1;
        this.$.overview.protoInput =
            this.$.overview.getStatsProto([{name: '', data: temp}]);
        this.calculateDistanceStats_(this.$.overview.protoInput.toObject());
        const tempSelected = this.$.dive.selectedData;
        this.$.dive.selectedData = [];
        this.$.dive.selectedData = tempSelected;
        this.updateSprite();
      },

      refreshDive_: function() {
        // Debounce a refresh request, for when multiple updates are happening
        // in succession.
        this.debounce('refreshDiveDebounce',
                      () => this.refreshDiveImpl_(), 500);
      },

      /**
       * Calculates and stores distance stats for each feature, used for
       * calculating distances between examples.
       */
      calculateDistanceStats_: function(statsProto) {
        this.distanceStats_ = {};
        for (let i = 0; i < statsProto.datasetsList[0].featuresList.length;
             i++) {
          const featureStats = statsProto.datasetsList[0].featuresList[i];
          const feature = featureStats.name;
          this.distanceStats_[feature] = {};
          if (featureStats.numStats) {
            // For numeric features, store standard deviation.
            this.distanceStats_[feature].stdDev = featureStats.numStats.stdDev;
          } else {
            // For categorical features, calculate and store  the probability
            // that any two feature values across all examples are the same.
            let probSameValue = 0;
            const buckets = featureStats.stringStats.rankHistogram.bucketsList;
            for (let j = 0; j < buckets.length; j++) {
              const probEntry =
                buckets[j].sampleCount /
                featureStats.stringStats.commonStats.numNonMissing;
                probSameValue += probEntry * probEntry;
            }
            this.distanceStats_[feature].probSameValue = probSameValue;
          }
        }
      },

      /**
       * Calls the backend to update a changed example.
       */
      updateExample_: function(exampleJson, index){
        this.fire('update-example', {'example': exampleJson, 'index': index});
        if (!this.local) {
          var url = this.makeUrl_('/data/plugin/whatif/update_example', null);

          this.makeAsyncRequest_(url, null, {'example': exampleJson,
                                              'index': index});
        }
      },

      getInferenceHolderId_: function() {
        return 'inference_';
      },

      makeUrl_: function(prefix, paramsDict){
        const url = prefix;
        if (paramsDict) {
          prefix += '?' + Object.keys(paramsDict).map(
            k => k + '=' + encodeURIComponent(paramsDict[k])).join('&');
        }
        return prefix;
      },

      showToast_: function(msg) {
        var toast = document.createElement('paper-toast');
        toast.duration = 10000;
        document.body.appendChild(toast);
        toast.text = msg;
        toast.show();

        // Also, log to console.
        console.error(msg);
      },

      makeAsyncRequest_: function(
          url, thenDoFn, postData, errorFn = () => {}) {
        const wrapperFn = this._canceller.cancellable(result => {
          if (result.cancelled) {
            return;
          }
          if (result.value && result.value.error){
            // show toast with the error
            this.showToast_(result.value.error);
            this.$.spinner.hidden = true;
            if (errorFn != null) {
              errorFn();
            }
          } else if (thenDoFn) {
            thenDoFn(result);
          }
        });
        this._requestManager.request(url, postData).then(wrapperFn)
            .catch(reason => {
              this.exampleStatusStr = 'Request failed';
              this.showToast_('Request failed: ' + reason);
              this.$.spinner.hidden = true;
              if (errorFn != null) {
                errorFn();
              }
            });
      },

      /**
       * Extract the data point feature value from an example feature. If
       * squeeze is true then convert length 1 arrays into single objects.
       */
      dataPointValueFromFeature_: function(feature, squeeze) {
        let valueList = null;
        if (feature.int64List) {
          valueList = feature.int64List.value;
        } else if (feature.floatList) {
          valueList = feature.floatList.value;
        } else if (feature.bytesList && feature.bytesList.value) {
          valueList = feature.bytesList.value.map(val => {
            // Strings above a max length are most likely binary encoded data
            // and not strings and therefore shouldn't be decoded for display
            // in Facets Dive.
            if (val.length > maxStringLengthToDecode) {
              return 'ERROR: string not decoded due to length';
            }
            try {
              return atob(val);
            } catch (err) {
              console.error('Error decoding string: ' + err);
              return 'ERROR: error decoding string';
            }
          });
        }
        // For value lists that are of length 1, treat the feature value
        // as just the item and not the list of length 1.
        if (squeeze && valueList && valueList.length == 1) {
          let singleValue = valueList[0];
          // For numeric feature values, convert the string to a number.
          if (!isNaN(singleValue)) {
            return Number(singleValue);
          } else {
            return singleValue;
          }
        }
        return valueList;
      },

      /**
       * Converts a single TF Example or SequenceExample into an item dict for
       * display in Facets Dive.
       */
      exampleToDataPoint_: function(example, index) {
        const d = {};
        // Extract the standard features from examples or context features from
        // sequence examples.
        const featureRoot = example.features || example.context;
        const features = featureRoot && 'feature' in featureRoot ?
            Object.keys(featureRoot.feature) : [];
        for (const index in features) {
          const fname = features[+index];
          // Ignore encoded image feature when creating data for Facets Dive.
          // The image will instead be used for the display sprite for the item
          // in Dive.
          if (fname == this.imageFeatureName) {
            continue;
          }
          let v = this.dataPointValueFromFeature_(
            featureRoot.feature[fname], true);
          if (v != null) {
            d[fname] = v;
          }
        }

        // For sequence examples, extract the sequence feature values.
        const featureLists = 'featureLists' in example ?
            Object.keys(example.featureLists.featureList) : [];
        for (const index in featureLists) {
          const fname = featureLists[+index];
          const fList = example.featureLists.featureList[fname].feature;
          let v = [];
          // Concatenate feature values from all values in the sequence for
          // each feature.
          for (let i = 0; i < fList.length; i++) {
            const newV = this.dataPointValueFromFeature_(fList[i], false);
            if (newV) {
              v = v.concat(newV)
            }
          }
          d[fname] = v;
        }
        d[exampleIdKey] = index;
        return d;
      },

      getExamplesAndCloseSettings_: function() {
        this.settingsClicked_();
        this.updateNumberOfModels();
        this.getExamples_();
      },

      showModelNumbers_: function() {
        return this.numModels <= 1;
      },

      /**
       * Callback for when new examples are received from the backend.
       */
      updateExampleContents: function(examples, hasSprite) {
        this.exampleStatusStr = examples.length + ' datapoints loaded';
        this.$.noexamples.style.display = 'none';
        this.$.spinner.hidden = true;
        this.examplesAndInferences = examples.map(function(ex) {
          const example = JSON.parse(ex);
          return {example: example, changed: false, orig: JSON.parse(ex)};});
        this.updatedExample = true;
        const self = this;
        this.visdata = this.examplesAndInferences.map(function(ex, i) {
          return self.exampleToDataPoint_(ex.example, i);
        });
        this.$.dive.atlasUrl = '';
        this.$.dive.imageFieldName = '';
        this.hasSprite = hasSprite;
        this.refreshDive_();
        if (!this.shouldDisableInferButton_(
            this.examplesAndInferences, this.modelName, this.inferenceAddress,
            this.updatedExample)) {
          this.inferClicked_();
        }
        this.setInferenceFromExampleData();
      },

      /**
       * If the example data contains inference results, as in the case with
       * pre-computed model results, then set the appropriate inference results.
       */
      setInferenceFromExampleData: function() {
        // If the examples contain the classification results or regression
        // results keys, then set the classification results from the
        // information in the examples.
        if (this.visdata.length > 0) {
          if (this.visdata[0][classificationResultsKey] != null) {
            const inferences = {};
            const indices = Array.apply(
              null, {length: this.visdata.length}).map(Number.call, Number);
            inferences.indices = indices;
            inferences.results = [
              {classificationResult: {classifications: []}}];
            for (let i = 0; i < indices.length; i++) {
              inferences.results[0].classificationResult.classifications[i] =
                {classes: [
                  {label: '0',
                   score: this.visdata[i][classificationResultsKey][0]},
                  {label: '1',
                   score: this.visdata[i][classificationResultsKey][1]}]};
            }
            this.inferences = inferences;
          } else if (this.visdata[0][regressionResultsKey] != null) {
            const inferences = {};
            const indices = Array.apply(
              null, {length: this.visdata.length}).map(Number.call, Number);
            inferences.indices = indices;
            inferences.results = [{regressionResult: {regressions: []}}];
            for (let i = 0; i < indices.length; i++) {
              inferences.results[0].regressionResult.regressions[i] =
                {value: this.visdata[i][regressionResultsKey]};
            }
            this.inferences = inferences;
          }
        }
      },

      getExamples_: function(){
        var url = this.makeUrl_('/data/plugin/whatif/examples_from_path',
                                {'examples_path': this.examplesPath,
                                 'max_examples': this.maxExamples,
                                 'sampling_odds': this.samplingOdds,
                                 'sequence_examples': this.sequenceExamples});

        const updateExampleContents = result => {
          this.updateExampleContents(
            result.value.examples, result.value.sprite);
        };
        this.exampleStatusStr = 'Loading datapoints...'
        this.makeAsyncRequest_(url, updateExampleContents, null);
        this.$.spinner.hidden = false;
      },

      updateSprite: function() {
        if (this.hasSprite) {
          this.$.dive.atlasUrl = null;
          if (!this.local) {
            this.$.dive.atlasUrl =
              this.makeUrl_('/data/plugin/whatif/sprite', {});
          } else {
            this.$.dive.atlasUrl = this.localAtlasUrl;
          }
        }
      },

      selectedDataUpdated_: function() {
        this.selectedExampleNum = this.selected.length > 0 ? this.selected[0] : "";
        if (this.visdata && this.visdata.length > 0) {
          this.partialDepPlotPendingFeatures = [];
        }
      },

      /**
       * Handler for copying a datapoint to a new datapoint.
       */
      copyDatapoint_: function() {
        const exampleJsonString =
          JSON.stringify(this.selectedExampleAndInference.example);
        const example = JSON.parse(exampleJsonString);
        const exampleAndInference = {example: example, changed: false,
          orig: JSON.parse(exampleJsonString)};
        this.examplesAndInferences.push(exampleAndInference);
        this.selectedExampleAndInference = exampleAndInference;
        this.visdata.push(
          this.exampleToDataPoint_(exampleAndInference.example,
                                   this.visdata.length));
        const duplicatedIndex = this.selected[0];

        this.showNearestCounterfactual = false;

        // Automatically select the new datapoint.
        this.selected[0] = this.visdata.length - 1;
        this.selectedDataUpdated_();

        this.updatedExample = true;

        // Inform the backend of the new example.
        this.fire('duplicate-example', {'index': duplicatedIndex});
        if (!this.local) {
          const refreshDiveAfterDuplicate = result => {
           this.refreshDive_();
          };
          const url = this.makeUrl_('/data/plugin/whatif/duplicate_example',
            {'index': duplicatedIndex});
          this.makeAsyncRequest_(url, refreshDiveAfterDuplicate, null);
        } else {
          this.refreshDive_();
        }
      },

      deleteDatapointDialog_: function() {
        this.$.deletedialog.open();
      },

      /**
       * Handler for deleting a datapoint.
       */
      deleteDatapoint_: function() {
        // Remove the datapoint, unselect it, and inform the backend.
        const deletedIndex = this.selected[0];
        this.examplesAndInferences.splice(deletedIndex, 1);
        this.visdata.splice(deletedIndex, 1);

        // Fix example IDs due to deleted index.
        for (let i = deletedIndex; i < this.visdata.length; i++) {
          this.visdata[i][exampleIdKey] = i;
        }

        this.comparedIndices = [];
        this.selected = [];
        this.selectedDataUpdated_();
        this.fire('delete-example', {'index': deletedIndex});
        this.$.dive.selectedIndices = [];
        if (!this.local) {
          const refreshDiveAfterDelete = result => {
           this.refreshDive_();
          };
          const url = this.makeUrl_('/data/plugin/whatif/delete_example',
            {'index': deletedIndex});
          this.makeAsyncRequest_(url, refreshDiveAfterDelete, null);
        } else {
          this.refreshDive_();
        }
      },

      shouldDisableReset_: function(exampleChanged) {
        return !exampleChanged;
      },

      /**
       * Handler for resetting an edited datapoint.
       */
      resetDatapoint_: function() {
        // Force reset of example in example viewer component by clearing out
        // the example and then waiting a frame to set it back to the original
        // value.
        this.set('selectedExampleAndInference.example', {});

        requestAnimationFrame(() => {
          this.selectedExampleAndInference.changed = false;
          const origExampleJsonString = JSON.stringify(
            this.selectedExampleAndInference.orig);
          this.set('selectedExampleAndInference.example',
                   JSON.parse(origExampleJsonString));
          this.visdata[this.selected[0]] = this.exampleToDataPoint_(
            this.selectedExampleAndInference.example, this.selected[0]);
          this.updatedExample = true;
          this.updateExample_(origExampleJsonString, this.selected[0]);
          this.refreshDive_();
        });
      },

      /**
       * Add a partial dependence plot for a given feature.
       */
      addChart: function(chartType, featureName, data){
        let chart;
        let dataToChart = data;

        // If multiclass and there are more inferred classes than the set
        // number of classes to display, then filter the classes to display
        // in the chart down to the top scoring classes.
        if (this.isMultiClass_(this.modelType, this.multiClass)) {
          dataToChart = [];
          for (let modelIdx = 0; modelIdx < data.length; modelIdx++) {
            let modelDataToChart = {};
            if (Object.keys(data[modelIdx]).length >
                Number(this.maxInferenceEntriesPerRun)) {
              const exampleId = this.selected &&
                this.selected.length > 0 ? this.selected[0] : 0;
              // Get the class labels of the top scoring classes from the most
              // recent inference.
              const currentExample = this.examplesAndInferences[exampleId];
              const lastInference = currentExample.inferences[
                currentExample.inferences.length - 1];
              const labels = lastInference[modelIdx].slice(
                0, this.maxInferenceEntriesPerRun);
              for (let labelIdx = 0; labelIdx < labels.length; labelIdx++) {
                const label = labels[labelIdx].label;
                modelDataToChart[label] = data[modelIdx][label];
              }
            } else {
              modelDataToChart = data[modelIdx];
            }
            dataToChart.push(modelDataToChart);
          }
        }

        if (chartType == 'numeric'){
          chart = this.makeLineChart(featureName, dataToChart);
        } else if (chartType == 'categorical'){
          chart = this.makeBarChart(featureName, dataToChart);
        } else {
          console.error('Unknown chartType: ' + chartType);
        }

        const container = this.featureContainerByName(featureName);

        // Append chart
        const categoryPane =
          container.querySelector('.tf-category-pane-content');
        Polymer.dom(categoryPane).appendChild(chart);

        // Remove the feature from pending queue, so it can be called again.
        const feature_ind =
          this.partialDepPlotPendingFeatures.indexOf(featureName);
        if (feature_ind > -1) {
          this.partialDepPlotPendingFeatures.splice(feature_ind, 1);
        }
      },

      getSimpleAxisFormatter: function(precision) {
        return Plottable.Formatters.general(precision);
      },

      makeBarChart: function(featureName, data){
        // array of categorical data objects (keys are labels):
        // {"1": [{"step": ["Divorced"], "scalar": 0.1533520370721},
        //    {"step": ["Married-AF-spouse"], "scalar": 0.153403326869}]},
        // one object per model

        function convertPoint(point, origKey){
          // point: {"step": ["Divorced"], "scalar": 0.1533520370721817}
          return {
            x: (point.step ==
              origKey) ? point.step + ' - original value' : point.step,
            y: point.scalar
          };
        };

        function convertThreshold(point, origKey, threshold){
          return {
            x: (point.step ==
              origKey) ? point.step + ' - original value' : point.step,
            scalar: point.scalar,
            y: threshold
          };
        };

        // Overwrite the key for original value so that it reads under the bar
        let origKey = '';
        const firstModelValues = data[0];
        if (!this.globalPdPlots) {
          const origValEntry =
            this.createPdEntryForCurrentValue(featureName, firstModelValues, 0);
          if (origValEntry) {
            origKey = origValEntry.step;
          }
        }

        // Convert the data into the format expected by vz-bar-chart.
        // Stack models and labels so that each (model,label) is a separate
        // series
        const lines = {};
        const mapped = {};
        const self = this;
        _.forEach(data, (modelValues, modelInd) => {
          const obj = _.forEach(modelValues,
            (pointsForSeries, labelKey) => {
              // Sort bars by their inference values for display.
              mapped[this.formatChartKey(labelKey, modelInd, data.length)] =
                _.map(pointsForSeries, point => convertPoint(
                  point, origKey)).sort((a, b) => b.y - a.y);
              // For binary classifiers, also create lines to indicate the
              // classification threshold for each model, with datapoints
              // sorted by the inference values to match the bar order for
              // the bar chart it will be displayed over.
              if (this.isBinaryClassification_(
                    this.modelType, this.multiClass)) {
                lines[this.formatChartKey(labelKey, modelInd, data.length)] =
                  _.map(pointsForSeries, point => convertThreshold(
                    point, origKey,
                    this.overallThresholds[modelInd].threshold)).sort(
                      (a, b) => b.scalar - a.scalar);
              }
            });
        });

        const valueFormatter = vz_chart_helpers.multiscaleFormatter(
          vz_chart_helpers.Y_TOOLTIP_FORMATTER_PRECISION);
        const toolTipColumns = [
          {
              title: 'Inference value',
              evaluate: d => {
                const splitLabel =
                    this.splitChartKey(d.key, data.length);
                let label = splitLabel.label;
                if (!isNaN(label) && label.length > 0 && this.labelVocab) {
                  const index = +label;
                  if (index < this.labelVocab.length && index >= 0) {
                    label += ' (' + this.labelVocab[index] + ')';
                  }
                }
                return label;
              }
          },
          {
              title: 'Feature value',
              evaluate: d => d.value.x,
          },
          {
              title: 'Score',
              evaluate: d => valueFormatter(d.value.y),
          },
        ];
        // If there is more than 1 model, show model number tooltip
        if (data.length >= 2){
          toolTipColumns.push(
            {
              title: 'Model',
              evaluate: d => {
                const label = this.splitChartKey(d.key, data.length);
                return label.model;
              }
            });
        }

        const holder = document.createElement('div');
        holder.classList.add('pd-holder');
        const chart = document.createElement('vz-bar-chart');
        chart.colorScale = new Plottable.Scales.Color().range(
          this.pdPlotColors);
        chart.linesColorScale = new Plottable.Scales.Color().range(
          this.pdPlotTransparentColors);
        chart.data = mapped;
        chart.lines = lines;
        chart.tooltipColumns = toolTipColumns;
        holder.appendChild(chart);

        const yLabel = document.createElement('div');
        yLabel.classList.add('pd-y-label');
        yLabel.innerText = this.isRegression_(this.modelType) ?
            'Inference value' : 'Inference score';
        holder.appendChild(yLabel);

        return holder;
      },

      splitChartKey: function (labelKey, numberOfModels){
          // If there is model key split it, otherwise just return original
          // label (index i) (model m) -> label (index #), m
          let keyToChart = labelKey;
          let modelToChart = '';
          if (numberOfModels >= 2) {
            const indexOfModelStr = labelKey.indexOf('(model');
            keyToChart = labelKey.substring(0, indexOfModelStr);
            modelToChart =
              labelKey.substring(indexOfModelStr + 7,
                labelKey.lastIndexOf(')'));
          }
          return {'label': keyToChart, 'model': modelToChart};
      },

      formatChartKey: function (labelKey, modelInd, numberOfModels) {
        if (numberOfModels == 1) {
          return labelKey;
        } else {
          return labelKey + ' (model ' + this.getModelName_(modelInd) + ')';
        }
      },

      makeLineChart: function(featureName, data){
        // numerical data:
        // {"0" (model id):
        //     {"1" (label): [{"step": 19.0, "scalar": 0.09157766401767},
        //        {"step": 23.444444444444443, "scalar": 0.10299546271562}]}}

        const holder = document.createElement('div');
        holder.classList.add('pd-holder');
        const chart = document.createElement('vz-line-chart');
        const colorScale = [];
        const thresholdSeries = [];
        const valueFormatter = vz_chart_helpers.multiscaleFormatter(
          vz_chart_helpers.Y_TOOLTIP_FORMATTER_PRECISION);
        const formatValueOrNaN = function (x) {
          return Number.isNaN(x) ? 'NaN' : valueFormatter(x);
        };
        if (this.modelType == 'classification') {
          chart.defaultYRange = [0, 1];
        }
        const toolTipColumns = [
          {
              title: 'Inference value',
              evaluate: d => {
                const splitLabel =
                    this.splitChartKey(d.dataset.metadata().name,
                      data.length);
                let label = splitLabel.label;
                if (!isNaN(label) && label.length > 0 && this.labelVocab) {
                  const index = +label;
                  if (index < this.labelVocab.length && index >= 0) {
                    label += ' (' + this.labelVocab[index] + ')';
                  }
                }
                return label;
              }
          },
          {
              title: 'Feature value',
              evaluate: d => formatValueOrNaN(d.datum.step),
          },
          {
              title: 'Score',
              evaluate: d => formatValueOrNaN(d.datum.scalar),
          },
        ];
        // If there is more than 1 model, show model number tooltip
        if (data.length >= 2) {
          toolTipColumns.push(
            {
              title: 'Model',
              evaluate: d => {
                const label = this.splitChartKey(d.dataset.metadata().name,
                  data.length);
                return label.model;
              }
            });
        }
        chart.tooltipColumns = toolTipColumns;

        const allSeries = [];
        let colorIndex = 0;
        for (let modelInd = 0; modelInd < data.length; modelInd++){
          const modelData = data[modelInd];
          const series = _.keys(modelData);
          colorIndex = modelInd * series.length;
          series.forEach(label => {
            colorScale.push(this.pdPlotColors[colorIndex++]);
            const thisLabel = this.formatChartKey(label, modelInd, data.length);
            chart.setSeriesData(thisLabel, modelData[label]);
            allSeries.push(thisLabel);
          });
          // Make a series for the current value of the feature to show in the
          // plot.
          colorIndex = modelInd * series.length;
          if (!this.globalPdPlots) {
            const origValEntry =
              this.createPdEntryForCurrentValue(featureName, modelData,
                modelInd);
            if (origValEntry) {
              const showKey = this.formatChartKey(
                _.keys(modelData)[0] + ' - original value ', modelInd,
                  data.length);
              chart.setSeriesData(showKey, [origValEntry]);
              allSeries.push(showKey);
              colorScale.push(this.pdPlotColors[colorIndex].brighter());
            }
          }
          if (this.isBinaryClassification_(this.modelType, this.multiClass)) {
            const label = this.formatChartKey(
              "classification threshold", modelInd, data.length);
            const thresholdData = data[0][_.keys(data[0])].map(point => {
              return {'step': point.step,
                      'scalar': this.overallThresholds[modelInd].threshold};
              });
            colorScale.push(this.pdPlotTransparentColors[colorIndex]);
            chart.setSeriesData(label, thresholdData);
            thresholdSeries.push(label);
            allSeries.push(label);
          }
        }
        chart.colorScale = new Plottable.Scales.Color().range(colorScale);
        chart.xAxisFormatter = this.getSimpleAxisFormatter(this.axisPrecision);
        chart.yAxisFormatter = this.getSimpleAxisFormatter(this.axisPrecision);
        // Do not show tooltips for the lines indicating model threshold values.
        chart.seriesWithoutTooltips = thresholdSeries;
        chart.colorScale.domain(allSeries);
        chart.setVisibleSeries(allSeries);
        holder.appendChild(chart);

        const yLabel = document.createElement('div');
        yLabel.classList.add('pd-y-label');
        yLabel.innerText = this.isRegression_(this.modelType) ?
            'Inference value' : 'Inference score';
        holder.appendChild(yLabel);
        const xLabel = document.createElement('div');
        xLabel.classList.add('pd-x-label');
        xLabel.innerText = featureName;
        holder.appendChild(xLabel);

        return holder;
      },

      /**
       * Helper for making a partial dependence plot entry for the current
       * value for a feature.
       */
      createPdEntryForCurrentValue: function(featureName, data, modelInd) {
        // Extract the class and feature value index from the key of the PD
        // chart data .
        const key = _.keys(data)[0];
        const indexOfIndexStr = key.indexOf('index');
        let classToChart = +key;
        let indexForValue = 0;
        if (indexOfIndexStr > -1) {
          classToChart = +(key.substring(0, key.indexOf(' ')))
          indexForValue =
            +(key.substring(indexOfIndexStr + 6, key.indexOf(')')));
        }

        let origValue = this.visdata[this.selected[0]][featureName];
        if (Array.isArray(origValue)) {
          origValue = origValue[indexForValue];
        }

        const inferences = this.selectedExampleAndInference.inferences[
          this.selectedExampleAndInference.inferences.length - 1][modelInd];
        let origInferenceScore = -1;
        for (let i = 0; i < inferences.length; i++) {
          if (inferences[i].label == classToChart.toString() ||
              inferences[i].label == "") {
            origInferenceScore = inferences[i].score;
            break;
          }
        }
        if (origInferenceScore == -1) {
          return null;
        }
        return {step: origValue, scalar: origInferenceScore};
      },

      showToast: function(msg) {
        const toast = document.createElement('paper-toast');
        document.body.appendChild(toast);
        toast.text = msg;
        toast.show();

        // Also, log to console.
        console.error(msg);
      },

      deletePdPlotSpinner: function(featureName) {
        const container = this.featureContainerByName(featureName);
        deleteElement(container.querySelector('paper-spinner-lite'));
      },

      makeChartForFeature: function(chartType, featureName, data) {
        this.deletePdPlotSpinner(featureName);
        // A separate chart per feature index for features with multiple values
        data.forEach(
          subfeature => this.addChart(chartType, featureName, subfeature));
      },

      /**
       * Handler for getting partial dependence plot information for a given
       * feature.
       */
      getInferenceVisualization: function(featureName, event){
        // The range of x-values to interpolate over for numerical features.
        const xMin = this.getUniqueByEvent(event, '.x-min').value;
        const xMax = this.getUniqueByEvent(event, '.x-max').value;

        // For a numerical feature with many repeated values, we allow users to
        // restrict inference to a smaller range of indices by using a pattern
        // (e.g. "0,2,4-6" runs inference for indices 0, 2, 4, 5, 6).
        const featureIndexPattern =
          this.getUniqueByEvent(event, '.feature-index-pattern').value;

        const urlParams = {
          'feature_name': featureName,
          'inference_address': this.inferenceAddress,
          'model_name': this.modelName,
          'model_type': this.modelType,
          'model_version': this.modelVersion,
          'model_signature': this.modelSignature,
          'x_min': xMin,
          'x_max': xMax,
          'feature_index_pattern': featureIndexPattern,
          'example_index': this.globalPdPlots ? -1 : this.selected[0],
          'use_predict': this.usePredictApi,
          'predict_output_tensor': this.predictOutputTensor,
          'predict_input_tensor': this.predictInputTensor,
        };

        // Call into backend.
        if (!this.local) {
          const url = tf_backend.addParams(
            '/data/plugin/whatif/infer_mutants', urlParams);
          const chartMakerCallback = result => {
            return this.makeChartForFeature(
              result.value.chartType, featureName, result.value.data);
          }
          const chartErrorCallback = () => {
            return this.handleChartErrorForFeature(featureName);
          }
          this.makeAsyncRequest_(
            url, chartMakerCallback.bind(this), null,
            chartErrorCallback.bind(this));
        } else {
          this.fire('infer-mutants', urlParams);
        }

        // Show a spinner while the plot is being calculated.
        const container = this.featureContainerByName(
          featureName).querySelector('.tf-category-pane-content');
        const spinner = document.createElement('paper-spinner-lite');
        spinner.setAttribute('active', true);
        Polymer.dom(container).appendChild(spinner);
      },

      handleChartErrorForFeature: function(featureName) {
        // Remove the feature from pending queue, so it can be called again.
        const featureInd =
          this.partialDepPlotPendingFeatures.indexOf(featureName);
        if (featureInd > -1) {
          this.partialDepPlotPendingFeatures.splice(featureInd, 1);
        }
        // Delete the spinner.
        this.deletePdPlotSpinner(featureName);
      },

      shouldHideFeatureIndicesSelector: function(featureName, selected) {
        if (!selected || selected.length == 0 || !this.visdata ||
            this.visdata.length <= selected[0]) {
          return true;
        }
        const item = this.visdata[selected[0]];
        return !Array.isArray(item[featureName]);
      },

      /** Check if pd-input-container has any elements in it and hide it if it
        does not*/
      shouldHidePdInputContainer: function(samples, featureName, selected) {
        if (!this.shouldHideFeatureIndicesSelector(featureName, selected)
            || !samples){
          return false;
        } else {
          return true;
        }
      },

      /** Returns the feature container associated with the feature name. */
      featureContainerByName: function(featureName){
        return this.$$('[data-feature-name="' + featureName + '"]');
      },

      /** Return the feature container associated with the specific event. */
      featureContainerByEvent: function(event){
        let el = event.target;
        while (!el.classList.contains('feature-container')) {
          el = el.parentNode;
       }
       return el;
      },

      /** Gets the selector within .feature-container for the event. */
      getUniqueByEvent(event, selector){
        return this.featureContainerByEvent(event).querySelector(selector);
      },

      partialDepPlotEligibleFeaturesSet: function(features) {
        if (!features || features.length == 0) {
          return;
        }
        // Open up the first PD plot pane after the category panes have loaded.
        setTimeout(() => {
          if (this.$$('.pd-entry-container').hidden) {
            this.$$('.tf-category-pane').click();
          }
        }, 100);
      },

      /**
       * Handler for click on button to generate partial dependence plots for
       * a feature.
       */
      categoryPaneClicked: function(event){
        const featureContainer = this.featureContainerByEvent(event);

        const element = featureContainer.querySelector('.pd-entry-container')

        if (element.hasAttribute('hidden')){
          this.drawPdCharts_(event);
          this.showPdElement_(featureContainer);
        } else {
          this.hidePdElement_(featureContainer);
        }
      },

      /**
       * Handler for drawing partial dependence plots for a feature.
       */
      drawPdCharts_: function(event) {
        // Make sure the feature wasn't already requested.
        const featureName = event.model.get('item').name;
        if (this.partialDepPlotPendingFeatures.indexOf(featureName) > -1) {
          return;
        }
        this.partialDepPlotPendingFeatures.push(featureName);

        this.getInferenceVisualization(featureName, event);
      },

      /**
       * Handler for clearing the partial dependence plots for a feature.
       */
       clearPdElementCharts_: function(element) {
        // Delete all the charts.
        const charts = element.querySelectorAll('.pd-holder');
        charts.forEach(function(chart){
          deleteElement(chart);
        });
      },

      /**
       * Handler for closing the partial dependence plots holder for a feature.
       */
      hidePdElement_: function(featureContainer) {
        // Clear the plots
        const element = featureContainer.querySelector('.pd-entry-container');
        this.clearPdElementCharts_(element);
        element.setAttribute('hidden', true)
        // Handle icon
        const icon = featureContainer.querySelector('.pd-row-arrow');
        icon.classList.remove('normal-icon');
        icon.classList.add('rotated-icon');
        // Handle row style
        const row = featureContainer.querySelector('.perf-table-entry');
        row.classList.add('perf-table-row');
        row.classList.remove('perf-table-row-expanded');
      },

      showPdElement_: function(featureContainer) {
        const element = featureContainer.querySelector('.pd-entry-container');
        element.removeAttribute('hidden')
        // Handle icon
        const icon = featureContainer.querySelector('.pd-row-arrow');
        icon.classList.add('normal-icon');
        icon.classList.remove('rotated-icon');
        // Handle row style
        const row = featureContainer.querySelector('.perf-table-entry');
        row.classList.remove('perf-table-row');
        row.classList.add('perf-table-row-expanded');
      },

      hideAllPdElements_: function() {
        const elements = Polymer.dom(this.root).querySelectorAll('.feature-container');
        for (let i = 0; i < elements.length; i++) {
          this.hidePdElement_(elements[i]);
        }
      },

      pdInputChanged: function(event) {
        // Debounce a refresh request, for when multiple updates are happening
        // in succession.
        this.debounce('pdInputChangedDebounce',
                      () => this.pdInputChangedImpl(event), 500);
      },

      /**
       * Handler for changes in settings for a partial dependence plot.
       */
      pdInputChangedImpl: function(event) {
        // Hide all existing plots so they can be regenerated with the new
        // settings.
        const element =
          this.getUniqueByEvent(event, '.tf-category-pane-content');
        this.clearPdElementCharts_(element);
        // Draw new plots
        this.drawPdCharts_(event);
      },

      /**
       * Populates the partial dependence plots area for a selected example.
       */
      populatePdTabs: function() {
        // First hide all existing PD plots before refreshing.
        this.hideAllPdElements_();

        // Call into the backend to get the possible features to show plots for.
        if (!this.local) {
          const url =
              tf_backend.addParams(
                '/data/plugin/whatif/eligible_features', {});
          const setEligibleFields = result => {
            this.set('partialDepPlotEligibleFeatures', result.value);
          };
          this.makeAsyncRequest_(url, setEligibleFields, null);
        } else {
          this.fire('get-eligible-features');
        }
      },

      toggleTrueLabelSetup: function() {
        this.$.collapsetruelabel.toggle();
      },

      toggleExplorerSetup: function() {
        this.$$('#collapseexplorer').toggle();
      },

      toggleContextTools: function() {
        this.$.collapsecontexttools.toggle();
      },

      togglePerformance: function() {
        this.$.collapseperformance.toggle();
      },

      toggleInferenceResults: function() {
        this.$$('#collapseinference').toggle();
      },

      getExpandCollapseIcon: function(opened) {
        return opened ? 'expand-less' : 'expand-more';
      },

      getExpandCollapsePerfIconClass: function(opened) {
        return opened ? 'normal-icon' : 'rotated-icon';
      },

      getPerfTableRowClass: function(opened) {
        return opened ? 'perf-table-row-expanded' : 'perf-table-row';
      },

      getPerfTableModelClass: function(numModels) {
        return numModels < 2 ? 'perf-table-model-single' : 'perf-table-model';
      },

      getDatapointEditorTitle: function(selectedExampleNum, comparedIndices) {
        return this.getSectionTitle(
          'Edit', selectedExampleNum, comparedIndices);
      },

      getInferTitle: function(selectedExampleNum, comparedIndices) {
        return this.getSectionTitle(
          'Infer', selectedExampleNum, comparedIndices);
      },

      getSectionTitle: function(title, selectedExampleNum, comparedIndices) {
        let name = title;
        if (selectedExampleNum != null && selectedExampleNum !== '') {
          if (comparedIndices != null && comparedIndices.length > 0) {
            name += ' - Datapoints ' + selectedExampleNum + ' and ' + comparedIndices[0];
          }
          else {
            name += ' - Datapoint ' + selectedExampleNum;
          }
        }
        return name;
      },

      /**
       * Expands/collapses a row in the performance table based on a click.
       */
      togglePerfRow: function(event) {
        // Find the table index for which the click was made.
        let el = event.target;
        while (el != null && !el.dataset.index) {
          el = el.parentNode;
        }
        if (el == null) {
          return;
        }
        const index = el.dataset.index;

        // Toggle the appropriate 'opened' variable in the list
        // that backs the performance table.
        this.set('featureValueThresholds.' + index + '.opened',
                 !this.featureValueThresholds[index].opened);

        // If expanding a section, update inference stats to ensure
        // properly rendered ROC curve.
        if (this.featureValueThresholds[index].opened) {
          requestAnimationFrame(() => this.updateInferenceStats_(true));
        }
      },

      getPerformanceTabTitle: function(modelType, multiClass) {
        return this.isBinaryClassification_(modelType, multiClass) ?
            'Performance & Fairness' : 'Performance';
      },

      getPerfTableTitle: function(
          feature1, feature2, optimization, thresholds) {
        let str = this.getPrintableOptimizationName(optimization);
        if (feature1 == null || feature1.length == 0) {
          if (optimization == 'custom') {
            return 'Explore overall performance';
          } else {
            return str;
          }
        } else {
          let featStr = feature1;
          if (feature2 != null && feature2.length != 0) {
            featStr += '/' + feature2;
          }
          return str + ' for ' + thresholds.length + ' values of ' + featStr;
        }
      },

      getNoThresholdPerfTableTitle: function(feature1, feature2, thresholds) {
        if (feature1 == null || feature1.length == 0) {
          return 'Explore overall performance'
        } else {
          let str = feature1;
          if (feature2 != null && feature2.length != 0) {
            str += '/' + feature2;
          }
          return str + ' (' + thresholds.length + ' values)';
        }
      },

      getPrintableOptimizationName: function(optimization) {
        if (optimization == 'custom') {
          return 'Custom thresholds';
        } else if (optimization == 'unaware') {
          return 'Optimal single threshold';
        } else if (optimization == 'demoparity') {
          return 'Demographic parity thresholds';
        } else if (optimization == 'equalopp') {
          return 'Equal opportunity thresholds';
        } else if (optimization == 'equalacc') {
          return 'Equal accuracy thresholds';
        } else {
          return 'Optimal group thresholds';
        }
      },

      getFeatureSortBy: function(modelType, multiClass) {
        let sorts = ['Count', 'Alphabetical'];
        if (this.isBinaryClassification_(modelType, multiClass)) {
          sorts = sorts.concat(
            ['Accuracy', 'False positives', 'False negatives']);
        } else if (this.isMultiClass_(modelType, multiClass)) {
          sorts = sorts.concat(['Accuracy']);
        } else {
          sorts = sorts.concat(
            ['Mean error', 'Mean absolute error', 'Mean squared error']);
        }
        return sorts;
      },

      selectedFeatureSortChanged_: function(sort) {
        const temp = this.featureValueThresholds;
        this.featureValueThresholds = [];
        this.featureValueThresholds = this.sortFeatureValues(temp);

        if (this.regressionEntries_ != null) {
          const temp = this.regressionEntries_;
          this.regressionEntries_ = [];
          this.regressionEntries_ = this.sortRegressionEntries(temp);
        }
       },

       getSliderClass: function(index) {
         let str = 'slider ';
         str += (index == 0 ? 'slider-model-one' : 'slider-model-two');
         return str;
       },

       formatError: function(error) {
        return d3.format('.3f')(error);
       },

       expandAllPerformance: function() {
         if (this.featureValueThresholds == null) {
           return;
         }
         for (let i = 0; i < this.featureValueThresholds.length; i++) {
           this.set('featureValueThresholds.' + i + '.opened', true);
         }
         requestAnimationFrame(() => this.updateInferenceStats_(true));
       },

       collapseAllPerformance: function() {
         if (this.featureValueThresholds == null) {
           return;
         }
         for (let i = 0; i < this.featureValueThresholds.length; i++) {
           this.set('featureValueThresholds.' + i + '.opened', false);
         }
       },
    });

    // TODO(#2338): Remove this, and set up a "no TF" message properly.
    // Keep this in sync with `frontend_metadata` in
    // `interactive_inference_plugin.py`.
    tf_tensorboard.registerDashboard({
      plugin: PLUGIN_NAME,
      elementName: 'tf-interactive-inference-dashboard',
      tabName: 'What-If Tool',
    });

    })();
  </script>
</dom-module>
