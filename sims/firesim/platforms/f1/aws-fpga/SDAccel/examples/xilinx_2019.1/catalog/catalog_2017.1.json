{
    "name": "apps", 
    "displayName": "", 
    "description": "", 
    "categories": [
        {
            "name": "acceleration", 
            "displayName": "", 
            "description": "", 
            "categories": [], 
            "examples": [
                {
                    "name": "kmeans", 
                    "commit_id": "76f75048dd359ef028b528a7c4b405bd77831e4e", 
                    "description": [
                        "This is OpenCL Based K-Means clustering Implementation for Xilinx FPGA ", 
                        "Devices. K-means clustering is a method of vector quantization, that ", 
                        "is popular for cluster analysis in data mining. K-means clustering ", 
                        "aims to partition n observations into k clusters in which each ", 
                        "observation belongs to the cluster with the nearest mean, serving as", 
                        "a prototype of the cluster.", 
                        "", 
                        "The application sets two compute units by default so that it will fit ", 
                        "all Xilinx Devices. For bigger Xilinx Devices, user can increase the ", 
                        "number of Compute units in Makefile and can get better performance.", 
                        "It is tested upto 6 compute units for ku115 device and got ", 
                        "approximately 6x improvement with respect to single compute units, which ", 
                        "shows that application is more compute bound (not memory bound) and ", 
                        "performance is directly proportional to number of compute units.", 
                        "", 
                        "__Note__: This application is ported from Rodinia", 
                        "", 
                        "(https://www.cs.virginia.edu/~skadron/wiki/rodinia/)", 
                        "", 
                        "__Usage__\n\n ./kmeans -i input_file [-m max_nclusters ] [-n min_nclusters] [-g global_size] [-c golden_file] [options]", 
                        "", 
                        "\t -i filename      : file containing data to be clustered", 
                        "\t -m max_nclusters : maximum number of clusters allowed [default=5]", 
                        "\t -n min_nclusters : minimum number of clusters allowed [default=5]", 
                        "\t -g global_size   : Specify global size [default=1]", 
                        "\t -c golden_file   : Golden File for result comparison", 
                        "\t -b               : input file is in binary format", 
                        "\t -o               : output cluster center coordinates [default=off]"
                    ], 
                    "displayName": "K-Means", 
                    "version": "1.0", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "nearest_neighbor_linear_search", 
                    "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                    "description": [
                        "This is an optimized implementation of a nearest neighbor linear search algorithm targeting execution on a SDAccel supported FPGA acceleration card."
                    ], 
                    "displayName": "Nearest Neighbor Linear Search", 
                    "version": "3.0", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "prng", 
                    "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                    "description": [
                        "This is an optimized implementation of the pseudo random number generator algorithm", 
                        "The method used to generate a random number sequence is called complementary multiply with carry (CMWC)", 
                        "targeting exection on an SDAccel support FPGA acceleration card"
                    ], 
                    "displayName": "pseudo random number generator", 
                    "version": "1.0", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "smithwaterman", 
                    "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                    "description": [
                        "This is an optimized implementation of the smithwaterman algorithm targeting exection on an SDAccel support FPGA acceleration card.", 
                        "", 
                        "The main algorithm characteristics of this application are", 
                        "", 
                        "1. Compute MaxScore", 
                        "2. Systolic array implementation"
                    ], 
                    "displayName": "Smithwaterman Genetic Sequencing Demo", 
                    "version": "3.0", 
                    "author": "Xilinx"
                }
            ]
        }, 
        {
            "name": "getting_started", 
            "displayName": [
                "Getting Started Examples"
            ], 
            "description": [
                "This page contains examples for users who are new to Xilinx SDx OpenCL Flows. The focus of the examples is towards code optimization for Xilinx devices.The table lists various categories of examples in suggested order which users can follow.", 
                "", 
                "", 
                "__Prerequisites__", 
                " - User is familiar with basics of OpenCL flow.", 
                " - User has gone through SDx tutorial and is familiar with basics of tool functionality and terminology."
            ], 
            "categories": [
                {
                    "name": "clk_freq", 
                    "displayName": [
                        "Clock Frequency Optimization Examples"
                    ], 
                    "description": [
                        "Improving Kernel Clock Frequency through Optimized code."
                    ], 
                    "categories": [], 
                    "examples": [
                        {
                            "name": "critical_path_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This example shows a normal coding style which could lead to critical path issue and design will give degraded timing.  Example also contains better coding style which can improve design timing."
                            ], 
                            "displayName": "Critical Path(CL)", 
                            "key_concepts": [
                                "Critical Path handling", 
                                "Improve Timing"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "large_loop_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is a CNN (Convolutional Neural Network) based example which mainly focuses on Convolution operation of a CNN network. The goal of this example is to demonstrate a method to overcome kernel design timing failure issue. It also presents the effectiveness of using multiple compute units to improve performance."
                            ], 
                            "displayName": "Clock Frequency ~ Large Loop Count (C)", 
                            "keywords": [
                                "#pragma HLS ARRAY_PARTITION", 
                                "#pragma HLS PIPELINE", 
                                "#pragma HLS INLINE"
                            ], 
                            "key_concepts": [
                                "Clock Frequency", 
                                "Multiple Compute Units", 
                                "Convolutional Neural Networks"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "large_loop_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is a CNN (Convolutional Neural Network) based example which mainly focuses on Convolution operation of a CNN network. The goal of this example is to demonstrate a method to overcome kernel design timing failure issue. It also presents the effectiveness of using multiple compute units to improve performance."
                            ], 
                            "displayName": "Clock Frequency ~ Large Loop Count (CL) ", 
                            "keywords": [
                                "xcl_array_partition", 
                                "xcl_pipeline_loop", 
                                "always_inline"
                            ], 
                            "key_concepts": [
                                "Clock Frequency", 
                                "Multiple Compute Units", 
                                "Convolutional Neural Networks"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "split_kernel_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is a multi-filter image processing application to showcase effectiveness of Dataflow/Streams usage. This examples is intended to help developers to break down the complex kernels into multiple sub-functions using HLS Dataflow/Streams. It presents a way to concurrently execute multiple functions with better area utilization compared to a complex single kernel implementation. The main objective of this example is to showcase a way to build a optimal FPGA design which achieves maximum frequency with optimal resource utilization and achieves better performance compared to single complex kernel implementations."
                            ], 
                            "displayName": "Large application Splits into Multiple Kernels (C)", 
                            "keywords": [
                                "#pragma HLS DATAFLOW", 
                                "hls::stream", 
                                "#pragma HLS INLINE", 
                                "#pragma HLS ARRAY_PARTITION", 
                                "#pragma HLS PIPELINE"
                            ], 
                            "key_concepts": [
                                "Dataflow", 
                                "Stream"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "split_kernel_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is a multi-filter image processing application to showcase effectiveness of Dataflow/Streams usage. This examples is intended to help developers to break down the complex kernel into multiple sub-functions using OpenCL Dataflow. It presents a way to concurrently execute multiple functions with better area utilization compared to a complex single kernel implementation. The main objective of this example is to showcase a way to build a optimal FPGA design which achieves maximum frequency with optimal resource utilization and achieves better performance compared to single kernel implementations."
                            ], 
                            "displayName": "Large application Splits into Multiple Kernels(CL)", 
                            "keywords": [
                                "xcl_dataflow", 
                                "xcl_array_partition", 
                                "xcl_pipeline_loop"
                            ], 
                            "key_concepts": [
                                "Dataflow", 
                                "Stream"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "too_many_cu_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is simple example of vector addition to demonstrate effectiveness of using single compute unit with heavy work load to achieve better performance. Bad example uses multiple compute units to achieve good performance but it results in heavy usage of FPGA resources and area due to which design fails timing. Good example uses single compute unit to compute with heavier work load, it helps in less resource utilization and also helps in kernel scalability. To switch between Good/Bad cases use the flag provided in makefile."
                            ], 
                            "displayName": "Clock Frequency ~ Too Many Compute Units (C) ", 
                            "keywords": [
                                "#pragma HLS PIPELINE", 
                                "#pragma HLS ARRAY_PARTITION"
                            ], 
                            "key_concepts": [
                                "Clock Frequency", 
                                "Data Level Parallelism", 
                                "Multiple Compute Units"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "too_many_cu_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is simple example of vector addition to demonstrate effectiveness of using single compute unit with heavy work load to achieve better performance. Bad example uses multiple compute units to achieve good performance but it results in heavy usage of FPGA resources and area due to which design fails timing. Good example uses single compute unit to compute with heavier work load, it helps in less resource utilization and also helps in kernel scalability. To switch between Good/Bad cases use the flag provided in makefile."
                            ], 
                            "displayName": "Clock Frequency ~ Too Many Compute Units (CL) ", 
                            "keywords": [
                                "xcl_array_partition(complete, 1)", 
                                "xcl_pipeline_loop"
                            ], 
                            "key_concepts": [
                                "Clock Frequency", 
                                "Data Level Parallelism", 
                                "Multiple Compute Units"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }
                    ]
                }, 
                {
                    "name": "cpu_to_fpga", 
                    "displayName": [
                        "CPU_to_FPGA Examples"
                    ], 
                    "description": [
                        "Labs to showcase the cpu to fpga conversion with kernel optimizations."
                    ], 
                    "categories": [], 
                    "examples": [
                        {
                            "name": "00_cpu", 
                            "commit_id": "76f75048dd359ef028b528a7c4b405bd77831e4e", 
                            "description": [
                                "This is a simple example of matrix multiplication (Row x Col)."
                            ], 
                            "displayName": "Matrix Multiplication", 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "01_ocl", 
                            "commit_id": "76f75048dd359ef028b528a7c4b405bd77831e4e", 
                            "description": [
                                "This is a simple example of OpenCL matrix multiplication (Row x Col)."
                            ], 
                            "displayName": "Matrix Multiplication with OpenCL Kernel", 
                            "key_concepts": [
                                "OpenCL APIs"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "02_lmem_ocl", 
                            "commit_id": "76f75048dd359ef028b528a7c4b405bd77831e4e", 
                            "description": [
                                "This is a simple example of matrix multiplication (Row x Col) to demonstrate how to reduce number of memory accesses using local memory."
                            ], 
                            "displayName": "Matrix Multiplication with Local Memory", 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Local Memory"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "03_burst_rw_ocl", 
                            "commit_id": "76f75048dd359ef028b528a7c4b405bd77831e4e", 
                            "description": [
                                "This is a simple example of matrix multiplication (Row x Col) to demonstrate how to achieve better pipeline with burst read and write to/from local memory from/to DDR."
                            ], 
                            "displayName": "Matrix Multiplication Burst Read Write", 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Burst Read/Write"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "04_partition_ocl", 
                            "commit_id": "76f75048dd359ef028b528a7c4b405bd77831e4e", 
                            "description": [
                                "This is a simple example of matrix multiplication (Row x Col) to demonstrate how to achieve better performance by array partitioning and loop unrolling."
                            ], 
                            "displayName": "Matrix Multiplication Array Partition and Loop Unroll", 
                            "keywords": [
                                "xcl_pipeline_loop", 
                                "xcl_array_partition(complete, dim)", 
                                "opencl_unroll_hint"
                            ], 
                            "key_concepts": [
                                "Array Partition", 
                                "Loop Unroll"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }
                    ]
                }, 
                {
                    "name": "dataflow", 
                    "displayName": [
                        "Dataflow Examples"
                    ], 
                    "description": [
                        "Kernel Optimization through Macro Level Pipelining"
                    ], 
                    "categories": [], 
                    "examples": [
                        {
                            "name": "dataflow_func_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is simple example of vector addition to demonstrate Dataflow functionality in OpenCL Kernel. OpenCL Dataflow allows user to run multiple functions together to achieve higher throughput."
                            ], 
                            "displayName": "Dataflow Function OpenCL(CL)", 
                            "keywords": [
                                "xcl_dataflow", 
                                "xclDataflowFifoDepth"
                            ], 
                            "key_concepts": [
                                "Function/Task Level Parallelism"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "dataflow_loop_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is simple example of vector addition to demonstrate Loops Dataflow functionality of HLS. HLS Dataflow allows user to schedule multiple sequential loops concurrently to achieve higher throughput."
                            ], 
                            "displayName": "Loops Dataflow Using HLS Stream(C)", 
                            "keywords": [
                                "dataflow", 
                                "hls::stream<>"
                            ], 
                            "key_concepts": [
                                "Loop Dataflow"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "dataflow_pipes_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is simple example of vector addition to demonstrate OpenCL Pipe Memory usage. OpenCL PIPE memory functionality allows user to achieve kernel-to-kernel data transfer without using global memory."
                            ], 
                            "displayName": "Blocking Pipes (CL)", 
                            "keywords": [
                                "pipe", 
                                "xcl_reqd_pipe_depth", 
                                "read_pipe_block()", 
                                "write_pipe_block()"
                            ], 
                            "key_concepts": [
                                "Dataflow", 
                                "kernel to kernel pipes"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "dataflow_stream_array_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is simple example of Multiple Stages Vector Addition to demonstrate Array of Stream usage in HLS C Kernel Code."
                            ], 
                            "displayName": "Dataflow Using HLS Stream (C)", 
                            "keywords": [
                                "dataflow", 
                                "hls::stream<>"
                            ], 
                            "key_concepts": [
                                "Array of Stream"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "dataflow_stream_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is simple example of vector addition to demonstrate Dataflow functionality of HLS. HLS Dataflow allows user to schedule multiple task together to achieve higher throughput."
                            ], 
                            "displayName": "Dataflow Using HLS Stream", 
                            "keywords": [
                                "dataflow", 
                                "hls::stream<>"
                            ], 
                            "key_concepts": [
                                "Task Level Parallelism"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }
                    ]
                }, 
                {
                    "name": "debug", 
                    "displayName": [
                        "Debug/Profile Examples"
                    ], 
                    "description": [
                        "Debugging and Profiling of Kernel."
                    ], 
                    "categories": [], 
                    "examples": [
                        {
                            "name": "debug_printf_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is simple example of vector addition and printing of data that is computational result (addition). It is based on vectored addition that demonstrates printing of work item data (integer product in this case)"
                            ], 
                            "displayName": "Printf Usage in Kernel code (CL)", 
                            "keywords": [
                                "printf", 
                                "param:compiler.enableAutoPipelining=false"
                            ], 
                            "key_concepts": [
                                "Use of print statements for debugging"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "debug_profile_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is simple example of vector addition and printing profile data (wall clock time taken between start and stop). It also dump a waveform file which can be reloaded to vivado to see the waveform. Run command 'vivado -source ./scripts/open_waveform.tcl -tclargs <device_name>-<kernel_name>.<target>.<device_name>.wdb' to launch waveform viewer. User can also update batch to gui in sdaccel.ini file to see the live waveform while running application."
                            ], 
                            "displayName": " Printing Profile Data and Dumping Waveform file (CL)", 
                            "key_concepts": [
                                "Use of Profile API", 
                                "Waveform Dumping and loading"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }
                    ]
                }, 
                {
                    "name": "host", 
                    "displayName": [
                        "Host Examples"
                    ], 
                    "description": [
                        "OpenCL host code for optimized interfacing with Xilinx Devices"
                    ], 
                    "categories": [], 
                    "examples": [
                        {
                            "name": "concurrent_kernel_execution_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This example will demonstrate how to use multiple and out of order command queues to simultaneously execute multiple kernels on an FPGA."
                            ], 
                            "displayName": "Concurrent Kernel Execution (CL)", 
                            "keywords": [
                                "CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE", 
                                "clSetEventCallback()"
                            ], 
                            "key_concepts": [
                                "Concurrent execution", 
                                "Out of Order Command Queues", 
                                "Multiple Command Queues"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "copy_buffer_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This Copy Buffer example demonstrate how one buffer can be copied from another buffer."
                            ], 
                            "displayName": "Copy Buffer (CL)", 
                            "keywords": [
                                "cl::CommandQueue::enqueueCopyBuffer()"
                            ], 
                            "key_concepts": [
                                "Copy Buffer"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "data_transfer_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This example illustrates several ways to use the OpenCL API to transfer data to and from the FPGA"
                            ], 
                            "displayName": "Data Transfer (CL)", 
                            "keywords": [
                                "clEnqueueWriteBuffer()", 
                                "clEnqueueReadBuffer()", 
                                "clEnqueueMapBuffer()", 
                                "clEnqueueUnmapMemObject()"
                            ], 
                            "key_concepts": [
                                "OpenCL API", 
                                "Data Transfer", 
                                "Write Buffers", 
                                "Read Buffers", 
                                "Map Buffers", 
                                "Async Memcpy"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "device_query_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This example prints the OpenCL properties of the platform and its devices. It also displays the limits and capabilities of the hardware."
                            ], 
                            "displayName": "Device Query (CL)", 
                            "keywords": [
                                "clGetPlatformIDs()", 
                                "clGetPlatformInfo()", 
                                "clGetDeviceIDs()", 
                                "clGetDeviceInfo()"
                            ], 
                            "key_concepts": [
                                "OpenCL API", 
                                "Querying device properties"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "errors_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This example discuss the different reasons for errors in OpenCL and how to handle them at runtime."
                            ], 
                            "displayName": "Error Handling (CL)", 
                            "keywords": [
                                "CL_SUCCESS", 
                                "CL_DEVICE_NOT_FOUND", 
                                "CL_DEVICE_NOT_AVAILABLE"
                            ], 
                            "key_concepts": [
                                "OpenCL API", 
                                "Error handling"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "helloworld_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This example is a simple OpenCL application. It will highlight the basic flow of an OpenCL application."
                            ], 
                            "displayName": "Hello World (CL)", 
                            "key_concepts": [
                                "OpenCL API"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "kernel_swap_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This example shows how host can swap the kernels and share same buffer between two kernels exist in separate binary containers. For Non-XPR(Extended Partial Reconfiguration) Specific Devices, device memory can persist buffer data so both kernels can share data directly. Whereas in XPR devices, device memory does not persist the buffer data so host has to migrate data from device to host memory before swapping the next kernel. After kernel swap, host has to migrate the buffer back to device."
                            ], 
                            "displayName": "Vector Add - Vector Multiplication for XPR-NON_XPR Devices", 
                            "keywords": [
                                "clEnqueueMigrateMemObjects()", 
                                "CL_MIGRATE_MEM_OBJECT_HOST"
                            ], 
                            "key_concepts": [
                                "Handling Buffer sharing across multiple binaries for XPR-NON_XPR Platform", 
                                "Multiple Kernel Binaries", 
                                "Buffer sharing across Multiple binaries"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "multiple_devices_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This example show how to take advantage of multiple FPGAs on a system. It will show how to initialized an OpenCL context, allocate memory on the two devices and execute a kernel on each FPGA."
                            ], 
                            "displayName": "Multiple FPGA Devices Execution Concurrently (CL)", 
                            "keywords": [
                                "cl_device_id", 
                                "clGetDeviceIDs()"
                            ], 
                            "key_concepts": [
                                "OpenCL API", 
                                "Multi-FPGA Execution", 
                                "Event Handling"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "overlap_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This examples demonstrates techniques that allow user to overlap Host(CPU) and FPGA computation in an application. It will cover asynchronous operations and event object."
                            ], 
                            "displayName": "Overlap Host and OpenCL kernels (CL)", 
                            "keywords": [
                                "cl_event", 
                                "clCreateCommandQueue", 
                                "CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE", 
                                "clEnqueueMigrateMemObjects"
                            ], 
                            "key_concepts": [
                                "OpenCL API", 
                                "Synchronize Host and FPGA", 
                                "Asynchronous Processing", 
                                "Events", 
                                "Asynchronous memcpy"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "stream_access_ocl", 
                            "commit_id": "a921ac7e938cdf68692ea4622332a2db0e2620aa", 
                            "description": [
                                "This is a simple example that demonstrates on how to process an input stream of data for computation in an application. It shows how to perform asynchronous operations and event handling."
                            ], 
                            "displayName": "Stream Access (CL)", 
                            "keywords": [
                                "cl_event", 
                                "CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE"
                            ], 
                            "key_concepts": [
                                "OpenCL API", 
                                "Synchronize Host and FPGA", 
                                "Asynchronous Processing", 
                                "Events", 
                                "Asynchronous Data Transfer"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }
                    ]
                }, 
                {
                    "name": "kernel_opt", 
                    "displayName": [
                        "Kernel Optimization Examples"
                    ], 
                    "description": [
                        "Kernel Optimization for performance"
                    ], 
                    "categories": [], 
                    "examples": [
                        {
                            "name": "aos_vs_soa_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This example demonstrates how data layout can impact the performance of certain kernels. The example we will demonstrate how using the Structure of Array data layout can impact certain data parallel problems."
                            ], 
                            "displayName": "Array of Structure(AoS) vs Structure of Arrays(SoA) (CL)", 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Data Layout"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "array_partition_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This example shows how to use array partitioning to improve performance of a kernel"
                            ], 
                            "displayName": "Array Partitioning (CL)", 
                            "keywords": [
                                "xcl_array_partition", 
                                "complete"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Array Partitioning"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "dependence_inter_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This Example to demonstrate HLS pragma 'DEPENDENCE'. Using 'DEPENDENCE' pragma, user can provide additional dependency details to compiler which allow compiler to perform unrolling/pipelining to get better performance."
                            ], 
                            "displayName": "Loop Iteration Dependency (C)", 
                            "keywords": [
                                "DEPENDENCE", 
                                "inter"
                            ], 
                            "key_concepts": [
                                "Inter Dependence"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "lmem_2rw_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is simple example of vector addition to demonstrate how to utilized both ports of Local Memory memory."
                            ], 
                            "displayName": "Two Parallel Read/Write on Local Memory (C)", 
                            "keywords": [
                                "#pragma HLS UNROLL FACTOR=2"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "2port BRAM Utilization", 
                                "two read/write Local Memory"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "lmem_2rw_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is simple example of vector addition to demonstrate how to utilized both ports of Local Memory."
                            ], 
                            "displayName": "Two Parallel Read/Write on Local Memory (CL)", 
                            "keywords": [
                                "opencl_unroll_hint(2)"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "2port BRAM Utilization", 
                                "two read/write Local Memory"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "loop_fusion_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This example will demonstrate how to fuse two loops into one to improve the performance of an OpenCL  C/C++ Kernel."
                            ], 
                            "displayName": "Loop Fusion (C)", 
                            "keywords": [
                                "#pragma HLS PIPELINE"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Loop Fusion", 
                                "Loop Pipelining"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "loop_fusion_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This example will demonstrate how to fuse two loops into one to improve the performance of an OpenCL kernel."
                            ], 
                            "displayName": "Loop Fusion (CL)", 
                            "keywords": [
                                "xcl_pipeline_loop"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Loop Fusion", 
                                "Loop Pipelining"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "loop_perfect_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This nearest neighbor example is to demonstrate how to achieve better performance using perfect loop."
                            ], 
                            "displayName": "Improve performance using loop perfect (C)", 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "loop_perfect_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This nearest neighbor example is to demonstrate how to achieve better performance using loop perfect."
                            ], 
                            "displayName": "Improve performance using loop perfect (CL)", 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "loop_pipeline_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This example demonstrates how loop pipelining can be used to improve the performance of a kernel."
                            ], 
                            "displayName": "Loop Pipelining (CL)", 
                            "keywords": [
                                "xcl_pipeline_loop"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Loop Pipelining"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "loop_reorder_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is a simple example of matrix multiplication (Row x Col) to demonstrate how to achieve better pipeline II factor by loop reordering."
                            ], 
                            "displayName": "Loop Reorder for better Performance(C)", 
                            "keywords": [
                                "#pragma HLS PIPELINE", 
                                "#pragma HLS ARRAY_PARTITION"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Loop reorder to improve II"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "loop_reorder_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is a simple example of matrix multiplication (Row x Col) to demonstrate how to achieve better pipeline II factor by loop reordering."
                            ], 
                            "displayName": "Loop Reorder for better Performance(CL)", 
                            "keywords": [
                                "xcl_pipeline_loop", 
                                "xcl_array_partition(complete, 2)"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Loop reorder to improve II"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "partition_cyclicblock_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This example shows how to use array block and cyclic partitioning to improve performance of a kernel"
                            ], 
                            "displayName": "Array Block and Cyclic Partitioning (C)", 
                            "keywords": [
                                "#pragma HLS ARRAY_PARTITION", 
                                "cyclic", 
                                "block", 
                                "factor", 
                                "dim"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Array Partitioning", 
                                "Block Partition", 
                                "Cyclic Partition"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "partition_cyclicblock_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This example shows how to use array block and cyclic partitioning to improve performance of a kernel"
                            ], 
                            "displayName": "Array Block and Cyclic Partitioning (CL)", 
                            "keywords": [
                                "xcl_array_partition", 
                                "cyclic", 
                                "block"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Array Partitioning", 
                                "Block Partition", 
                                "Cyclic Partition"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "shift_register_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This example demonstrates how to shift values in registers in each clock cycle"
                            ], 
                            "displayName": "Shift Register (C)", 
                            "keywords": [
                                "#pragma HLS ARRAY_PARTITION"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Shift Register", 
                                "FIR"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "shift_register_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This example demonstrates how to shift values in registers in each clock cycle"
                            ], 
                            "displayName": "Shift Register (CL)", 
                            "keywords": [
                                "xcl_array_partition"
                            ], 
                            "key_concepts": [
                                "Kernel Optimization", 
                                "Shift Register", 
                                "FIR"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "systolic_array_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is a simple example of matrix multiplication (Row x Col) to help developers learn systolic array based algorithm design. Note : Systolic array based algorithm design is well suited for FPGA."
                            ], 
                            "displayName": "Systolic Array Implementation (C)", 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "systolic_array_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is a simple example of matrix multiplication (Row x Col) to help developers learn systolic array based algorithm design. Note: Systolic array based algorithm design is well suited for FPGA."
                            ], 
                            "displayName": "Systolic Array Implementation (CL)", 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }
                    ]
                }, 
                {
                    "name": "kernel_to_gmem", 
                    "displayName": [
                        "Kernel To Global Memory Examples"
                    ], 
                    "description": [
                        "Kernel to Global Memory Access Optimization."
                    ], 
                    "categories": [], 
                    "examples": [
                        {
                            "name": "burst_rw_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is simple example of using AXI4-master interface for burst read and write"
                            ], 
                            "displayName": "Burst Read/Write (C)", 
                            "keywords": [
                                "memcpy"
                            ], 
                            "key_concepts": [
                                "burst access"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "burst_rw_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is simple example of using AXI4-master interface for burst read and write"
                            ], 
                            "displayName": "Burst Read/Write (CL)", 
                            "key_concepts": [
                                "burst access"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "custom_datatype_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is simple example of RGB to HSV conversion to demonstrate Custom DATA Type usages in C Based Kernel. Xilinx HLS Compiler Supports Custom Data Type to use for operation as well as Memory Interface between Kernel and Global Memory."
                            ], 
                            "displayName": "Custom Data Type (C)", 
                            "keywords": [
                                "struct", 
                                "#pragma HLS data_pack", 
                                "#pragma HLS LOOP_TRIPCOUNT"
                            ], 
                            "key_concepts": [
                                "Custom Datatype"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "custom_datatype_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is simple example of RGB to HSV conversion to demonstrate Custom DATA Type usages in OpenCL Based Kernel. Xilinx HLS Compiler Supports Custom Data Type to use for operation as well as Memory Interface between Kernel and Global Memory."
                            ], 
                            "displayName": "Custom Data Type (CL)", 
                            "keywords": [
                                "struct"
                            ], 
                            "key_concepts": [
                                "Dataflow", 
                                "Custom Datatype"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "full_array_2d_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is a simple example of accessing full data from 2d array"
                            ], 
                            "displayName": "Full 2D Array Read/Write (C)", 
                            "key_concepts": [
                                "2D data full array Access"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "full_array_2d_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is a simple example of accessing full data from 2d array"
                            ], 
                            "displayName": "Full 2D Array Read/Write (CL)", 
                            "key_concepts": [
                                "2D data full array Access"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "gmem_2banks_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This example of 2ddr to demonstrate on how to use 2ddr DSA. How to create buffers in each DDR."
                            ], 
                            "displayName": "Global Memory Two Banks (C)", 
                            "keywords": [
                                "max_memory_ports", 
                                "misc:map_connect", 
                                "cl_mem_ext_ptr_t",
                                "XCL_MEM_DDR_BANK0", 
                                "XCL_MEM_DDR_BANK1", 
                                "XCL_MEM_DDR_BANKx",
                                "CL_MEM_EXT_PTR_XILINX",
                                "HLS Interface m_axi bundle"
                            ], 
                            "key_concepts": [
                                "Multiple Banks"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "gmem_2banks_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This example of 2ddr to demonstrate on how to use 2ddr DSA. How to create buffers in each DDR."
                            ], 
                            "displayName": "Global Memory Two Banks (CL)", 
                            "keywords": [
                                "max_memory_ports", 
                                "misc:map_connect",
                                "cl_mem_ext_ptr_t",
                                "XCL_MEM_DDR_BANK0", 
                                "XCL_MEM_DDR_BANK1", 
                                "XCL_MEM_DDR_BANKx",
                                "CL_MEM_EXT_PTR_XILINX"
                            ], 
                            "key_concepts": [
                                "Multiple Banks"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "memcoalesce_hang_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This example shows Memory Coalesce Deadlock/Hand situation and how to handle it. User can switch between BAD and GOOD case using makefile variable KFLOW."
                            ], 
                            "displayName": "Memory Coalesce Deadlock/Hang Handling (C)", 
                            "keywords": [
                                "HLS INTERFACE", 
                                "bundle", 
                                "m_axi"
                            ], 
                            "key_concepts": [
                                "Memory Coalesce", 
                                "Memory Deadlock/Hang", 
                                "Multiple Interfaces"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "row_array_2d_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is a simple example of accessing each row of data from 2d array"
                            ], 
                            "displayName": "Read/Write Row of 2D Array (C)", 
                            "keywords": [
                                "hls::stream"
                            ], 
                            "key_concepts": [
                                "Row of 2D data array access"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "row_array_2d_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is a simple example of accessing each row of data from 2d array"
                            ], 
                            "displayName": "Read/Write Row of 2D Array (CL)", 
                            "keywords": [
                                "xcl_dataflow", 
                                "xcl_pipeline_loop"
                            ], 
                            "key_concepts": [
                                "Row of 2D data array access"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "wide_mem_rw_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is simple example of vector addition to demonstrate Wide Memory Access using ap_uint<512> data type. Based on input argument type, xocc compiler will figure our the memory datawidth between Global Memory and Kernel. For this example, ap_uint<512> datatype is used, so Memory datawidth will be 16 x (integer bit size) = 16 x 32 = 512 bit."
                            ], 
                            "displayName": "Wide Memory Read/Write (C)", 
                            "keywords": [
                                "ap_uint<>", 
                                "ap_int.h"
                            ], 
                            "key_concepts": [
                                "Kernel to DDR", 
                                "wide memory access", 
                                "burst read and write"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "wide_mem_rw_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is simple example of vector addition to demonstrate Wide Memory Access using uint16 data type. Based on input argument type, xocc compiler will figure our the memory datawidth between Global Memory and Kernel. For this example, uint16 datatype is used, so Memory datawidth will be 16 x (integer bit size) = 16 x 32 = 512 bit."
                            ], 
                            "displayName": "Wide Memory Read/Write (CL)", 
                            "keywords": [
                                "uint16", 
                                "xcl_pipeline_loop"
                            ], 
                            "key_concepts": [
                                "Kernel to DDR", 
                                "wide memory access", 
                                "burst read and write"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "window_array_2d_c", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is a simple example of accessing each window of data from 2d array"
                            ], 
                            "displayName": "Read/Write Window of 2D Array (C)", 
                            "keywords": [
                                "#pragma HLS DATAFLOW", 
                                "#pragma HLS PIPELINE", 
                                "#pragma HLS stream"
                            ], 
                            "key_concepts": [
                                "window of 2D data array access"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "window_array_2d_ocl", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "This is a simple example of accessing each window of data from 2d array"
                            ], 
                            "displayName": "Read/Write Window of 2D Array (CL)", 
                            "keywords": [
                                "pipe", 
                                "xcl_pipeline_loop", 
                                "xcl_reqd_pipe_depth"
                            ], 
                            "key_concepts": [
                                "window/tile of 2D data array access"
                            ], 
                            "version": "1.0", 
                            "author": "Xilinx"
                        }
                    ]
                }, 
                {
                    "name": "misc", 
                    "displayName": [
                        "Miscellaneous Examples"
                    ], 
                    "description": [
                        "OpenCL miscellaneous Examples"
                    ], 
                    "categories": [], 
                    "examples": [
                        {
                            "name": "host_global_bandwidth", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "Host to global memory bandwidth test"
                            ], 
                            "displayName": "host_global", 
                            "version": "3.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "kernel_global_bandwidth", 
                            "commit_id": "e502a7e079b456f91effca52141fca89b62c619e", 
                            "description": [
                                "Bandwidth test of global to local memory."
                            ], 
                            "displayName": "kernel_global", 
                            "version": "3.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "sum_scan", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "Example of parallel prefix sum"
                            ], 
                            "displayName": "Parallel Prefix Sum", 
                            "version": "2.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "vadd", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "Simple example of vector addition."
                            ], 
                            "displayName": "Vector Addition", 
                            "version": "3.0", 
                            "author": "Xilinx"
                        }, 
                        {
                            "name": "vdotprod", 
                            "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                            "description": [
                                "Simple example of vector dot-product."
                            ], 
                            "displayName": "Vector Dot-Product", 
                            "version": "3.0", 
                            "author": "Xilinx"
                        }
                    ]
                }
            ], 
            "examples": []
        }, 
        {
            "name": "security", 
            "displayName": "", 
            "description": "", 
            "categories": [], 
            "examples": [
                {
                    "name": "aes_decrypt", 
                    "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                    "description": [
                        "Implementation of an AES-128 ECB Encrypt in software, followed by decryption written in OpenCL and targeting execution on an SDAccel supported FPGA acceleration card."
                    ], 
                    "displayName": "AES Decryption", 
                    "version": "3.0", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "rsa", 
                    "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                    "description": [
                        "This is an implementation of a RSA Decryption algorithm targeting execution on an SDAccel supported FPGA acceleration card."
                    ], 
                    "displayName": "RSA Decryption Example", 
                    "version": "2.0", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "sha1", 
                    "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                    "description": [
                        "This is an optimized implementation of SHA1 secure hash algorithm targeting execution on an SDAccel supported FPGA acceleration card."
                    ], 
                    "displayName": "SHA1", 
                    "version": "3.0", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "tiny_encryption", 
                    "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                    "description": [
                        "implementation of the tiny encryption algorithm."
                    ], 
                    "displayName": "Tiny Encryption", 
                    "version": "3.0", 
                    "author": "Xilinx"
                }
            ]
        }, 
        {
            "name": "vision", 
            "displayName": "", 
            "description": "", 
            "categories": [], 
            "examples": [
                {
                    "name": "affine", 
                    "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                    "description": [
                        "Affine transformation is a linear mapping method that preserves points, straight lines, and planes. Sets of parallel lines remain parallel after an affine transformation. The affine transformation technique is typically used to correct for geometric distortions or deformations that occur with non-ideal camera angles. The demo performs a 30 degree X rotation and a 50% X and Y scaling on a 512 by 512, 16 bits per pixels grayscale, raw MRI image."
                    ], 
                    "displayName": "Affine", 
                    "version": "2.0", 
                    "author": "Wakahara Project"
                }, 
                {
                    "name": "convolve", 
                    "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                    "description": [
                        "The convolve example is a performant design which showcases convolutional image filtering. The example processes the image 8 pixels at a time."
                    ], 
                    "displayName": "Convolve", 
                    "version": "3.0", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "edge_detection", 
                    "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                    "description": [
                        "Implementation of a Sobel Filter for edge detection."
                    ], 
                    "displayName": "Edge Detection", 
                    "version": "3.0", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "histogram_eq", 
                    "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                    "description": [
                        "This is an optimized implementation of a 12-bit histogram equalizer targeting execution on an SDAccel supported FPGA acceleration card."
                    ], 
                    "displayName": "Histogram Equalization", 
                    "version": "3.0", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "huffman_codec", 
                    "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                    "description": [
                        "This is an implementation of a huffman encoding/decoding algorithm targeting execution on an SDAccel supported FPGA acceleration card."
                    ], 
                    "displayName": "Huffman Encoding/Decoding", 
                    "version": "3.0", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "idct", 
                    "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                    "description": [
                        "Example of processing Inverse Discrete Cosine Transfom on multiple blocks of data."
                    ], 
                    "displayName": "Inverse Discrete Cosine Transform", 
                    "version": "1.0", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "median_filter", 
                    "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                    "description": [
                        "This is an optimized implementation of a median filter being used to remove noise in images targeting execution on an SDAccel supported FPGA acceleration card."
                    ], 
                    "displayName": "Median Filter", 
                    "version": "3.0", 
                    "author": "Xilinx"
                }, 
                {
                    "name": "watermarking", 
                    "commit_id": "5d6b726d4a1735660e8bdef776dc7ab63f429174", 
                    "description": [
                        "This is an optimized implementation of a watermarking application to add watermarking to images targeting execution on an SDAccel supported FPGA acceleration card."
                    ], 
                    "displayName": "Watermarking", 
                    "version": "4.0", 
                    "author": "Xilinx"
                }
            ]
        }
    ], 
    "examples": [], 
    "branch": "2017.1"
}
